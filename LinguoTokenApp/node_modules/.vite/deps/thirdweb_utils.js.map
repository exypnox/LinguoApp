{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/any-evm/is-eip155-enforced.ts", "../../thirdweb/src/utils/any-evm/keyless-transaction.ts", "../../thirdweb/src/contract/deployment/utils/create-2-factory.ts", "../../thirdweb/src/utils/any-evm/keccak-id.ts", "../../thirdweb/src/utils/any-evm/get-salt-hash.ts", "../../thirdweb/src/utils/any-evm/compute-deployment-address.ts", "../../thirdweb/src/utils/any-evm/get-init-bytecode-with-salt.ts", "../../thirdweb/src/utils/signatures/resolve-signature.ts", "../../thirdweb/src/utils/jwt/jwt-header.ts", "../../thirdweb/src/utils/jwt/decode-jwt.ts", "../../thirdweb/src/utils/jwt/encode-jwt.ts", "../../thirdweb/src/utils/jwt/refresh-jwt.ts", "../../thirdweb/src/utils/contract/parse-abi-params.ts"],
  "sourcesContent": ["import type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { eth_sendRawTransaction } from \"../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\n\n// it's OK to cache this forever because:\n// 1. the results can't change\n// 2. the total size can be max <number of chains> * boolean\nconst EIP_ENFORCED_CACHE = new Map<number, boolean>();\n\ntype IsEIP155EnforcedOptions = {\n  chain: Chain;\n  client: ThirdwebClient;\n};\n\n/**\n * Checks whether EIP-155 is enforced by sending a random transaction of legacy type (pre-EIP-155)\n * and parsing the error message.\n * @param options - The options for checking EIP-155 enforcement.\n * @returns A promise that resolves to a boolean indicating whether EIP-155 is enforced.\n * @example\n * ```ts\n * import { isEIP155Enforced } from \"thirdweb/utils\";\n * const isEIP155 = await isEIP155Enforced({ chain, client });\n * ```\n * @utils\n */\nexport async function isEIP155Enforced(\n  options: IsEIP155EnforcedOptions,\n): Promise<boolean> {\n  const chainId = options.chain.id;\n  // cache because the result cannot change\n  if (EIP_ENFORCED_CACHE.has(chainId)) {\n    return EIP_ENFORCED_CACHE.get(chainId) as boolean;\n  }\n  let result = false;\n  try {\n    // TODO: Find a better way to check this.\n\n    // Send a random transaction of legacy type (pre-eip-155).\n    // It will fail. Parse the error message to check whether eip-155 is enforced.\n    const rpcRequest = getRpcClient(options);\n    await eth_sendRawTransaction(\n      rpcRequest,\n      \"0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222\",\n    );\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  } catch (e: any) {\n    const errorMsg = e.toString().toLowerCase();\n    const errorJson = JSON.stringify(e).toLowerCase();\n\n    if (matchError(errorMsg) || matchError(errorJson)) {\n      result = true;\n    }\n  }\n  EIP_ENFORCED_CACHE.set(chainId, result);\n  return result;\n}\n\nconst ERROR_SUBSTRINGS_COMPOSITE = [\n  [\"account\", \"not found\"],\n  [\"wrong\", \"chainid\"],\n];\nconst ERROR_SUBSTRINGS = [\n  \"eip-155\",\n  \"eip155\",\n  \"protected\",\n  \"invalid chain id for signer\",\n  \"chain id none\",\n  \"chain_id mismatch\",\n  \"recovered sender mismatch\",\n  \"transaction hash mismatch\",\n  \"chainid no support\",\n  \"chainid (0)\",\n  \"chainid(0)\",\n  \"invalid sender\",\n];\n\nfunction matchError(error: string): boolean {\n  const hasError = ERROR_SUBSTRINGS.some((substring) =>\n    error.includes(substring),\n  );\n  // can early exit if we find a match\n  if (hasError) {\n    return true;\n  }\n\n  // otherwise return true if any of the composite substrings are found\n  return ERROR_SUBSTRINGS_COMPOSITE.some((arr) => {\n    let foundError = true;\n\n    for (const substring of arr) {\n      foundError &&= error.includes(substring);\n    }\n    return foundError;\n  });\n}\n", "import {\n  type Signature,\n  type TransactionSerializable,\n  recoverAddress,\n  serializeTransaction,\n  signatureToHex,\n} from \"viem\";\nimport { keccak256 } from \"../hashing/keccak256.js\";\n\ntype GetKeylessTransactionOptions = {\n  transaction: TransactionSerializable;\n  signature: Signature;\n};\n\n/**\n * Retrieves the keyless transaction information.\n *\n * @param options - The options for retrieving the keyless transaction.\n * @returns An object containing the signer address and the signed serialized transaction string.\n * @internal\n */\nexport async function getKeylessTransaction(\n  options: GetKeylessTransactionOptions,\n) {\n  // 1. Create serialized txn string\n  const hash = keccak256(serializeTransaction(options.transaction));\n\n  // 2. Determine signer address from custom signature + txn\n  const address = await recoverAddress({\n    hash,\n    signature: signatureToHex(options.signature),\n  });\n\n  // 3. Create the signed serialized txn string.\n  // To be sent directly to the chain using a provider.\n  const transaction = serializeTransaction(\n    options.transaction,\n    options.signature,\n  );\n\n  return {\n    signerAddress: address,\n    transaction,\n  };\n}\n", "import { getContractAddress } from \"viem\";\nimport { getGasPrice } from \"../../../gas/get-gas-price.js\";\nimport { eth_getBalance } from \"../../../rpc/actions/eth_getBalance.js\";\nimport { eth_sendRawTransaction } from \"../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../rpc/rpc.js\";\nimport { sendTransaction } from \"../../../transaction/actions/send-transaction.js\";\nimport { waitForReceipt } from \"../../../transaction/actions/wait-for-tx-receipt.js\";\nimport { prepareTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { isEIP155Enforced } from \"../../../utils/any-evm/is-eip155-enforced.js\";\nimport { getKeylessTransaction } from \"../../../utils/any-evm/keyless-transaction.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport type {\n  ClientAndChain,\n  ClientAndChainAndAccount,\n} from \"../../../utils/types.js\";\nimport { getContract } from \"../../contract.js\";\n\nconst COMMON_FACTORY_ADDRESS = \"0x4e59b44847b379578588920cA78FbF26c0B4956C\"; // for pre-eip-155 supporting chains\n\n/**\n * @internal\n */\nconst CREATE2_FACTORY_BYTECODE =\n  \"0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3\";\n/**\n * @internal\n */\nconst SIGNATURE = {\n  v: 27n,\n  r: \"0x2222222222222222222222222222222222222222222222222222222222222222\",\n  s: \"0x2222222222222222222222222222222222222222222222222222222222222222\",\n} as const;\n\n/**\n * Computes the address of the Create2 factory contract and checks if it is deployed.\n * @param options - The options for retrieving the Create2 factory address.\n * @returns whether the Create2 factory is deployed.\n * @internal\n */\nexport async function computeCreate2FactoryAddress(\n  options: ClientAndChain,\n): Promise<string> {\n  const chainId = options.chain.id;\n\n  return withCache(\n    async () => {\n      // special handling for chains with hardcoded gasPrice and gasLimit\n      if (CUSTOM_GAS_FOR_CHAIN[chainId]) {\n        const enforceEip155 = await isEIP155Enforced(options);\n        const eipChain = enforceEip155 ? chainId : 0;\n        const gasPrice = CUSTOM_GAS_FOR_CHAIN[chainId.toString()]?.gasPrice;\n        const gasLimit = CUSTOM_GAS_FOR_CHAIN[chainId.toString()]?.gasLimit;\n\n        const deploymentInfo = await _getCreate2FactoryDeploymentInfo(\n          eipChain,\n          {\n            gasPrice,\n            gasLimit,\n          },\n        );\n\n        return deploymentInfo.predictedAddress;\n      }\n\n      // default flow\n      const allBinsInfo = await Promise.all([\n        // to generate EIP-155 transaction\n        ...CUSTOM_GAS_BINS.map((b) => {\n          return _getCreate2FactoryDeploymentInfo(chainId, { gasPrice: b });\n        }),\n\n        // to generate pre EIP-155 transaction, hence chainId 0\n        ...CUSTOM_GAS_BINS.map((b) => {\n          return _getCreate2FactoryDeploymentInfo(0, { gasPrice: b });\n        }),\n      ]);\n\n      const allFactories = await Promise.all(\n        allBinsInfo.map((b) => {\n          const tempFactory = getContract({\n            ...options,\n            address: b.predictedAddress,\n          });\n          return isContractDeployed(tempFactory);\n        }),\n      );\n\n      const indexOfCommonFactory = allBinsInfo.findIndex(\n        (b) => b.predictedAddress === COMMON_FACTORY_ADDRESS,\n      );\n      if (indexOfCommonFactory && allFactories[indexOfCommonFactory]) {\n        return COMMON_FACTORY_ADDRESS;\n      }\n\n      const indexOfExistingDeployment = allFactories.findIndex((b) => b);\n      if (\n        indexOfExistingDeployment &&\n        allBinsInfo &&\n        allBinsInfo[indexOfExistingDeployment]?.predictedAddress\n      ) {\n        // TODO: cleanup\n        return allBinsInfo[indexOfExistingDeployment]\n          ?.predictedAddress as string;\n      }\n\n      const [enforceEip155, gasPriceFetched] = await Promise.all([\n        isEIP155Enforced(options),\n        getGasPrice(options),\n      ]);\n      const eipChain = enforceEip155 ? chainId : 0;\n      const bin = _getNearestGasPriceBin(gasPriceFetched);\n\n      const deploymentInfo = await _getCreate2FactoryDeploymentInfo(eipChain, {\n        gasPrice: bin,\n      });\n\n      return deploymentInfo.predictedAddress;\n    },\n    {\n      cacheKey: `create2factory:${chainId}`,\n      cacheTime: 24 * 60 * 60 * 1000, // 1 day\n    },\n  );\n}\n\n/**\n * @internal\n */\nexport async function getDeployedCreate2Factory(options: ClientAndChain) {\n  const address = await computeCreate2FactoryAddress(options);\n  const factory = getContract({\n    ...options,\n    address,\n  });\n  const isDeployed = await isContractDeployed(factory);\n  if (!isDeployed) {\n    return null;\n  }\n  return factory;\n}\n\n/**\n * Deploys the Create2 factory contract using a keyless transaction.\n * @internal\n */\nexport async function deployCreate2Factory(options: ClientAndChainAndAccount) {\n  const { client, chain, account } = options;\n  const enforceEip155 = await isEIP155Enforced(options);\n  const chainId = options.chain.id;\n  const eipChain = enforceEip155 ? chainId : 0;\n\n  const rpcRequest = getRpcClient({\n    client: client,\n    chain,\n  });\n\n  const gasPriceFetched = await getGasPrice(options);\n  const bin = _getNearestGasPriceBin(gasPriceFetched);\n  const deploymentInfo = await _getCreate2FactoryDeploymentInfo(eipChain, {\n    gasPrice: bin,\n  });\n\n  const balance = await eth_getBalance(rpcRequest, {\n    address: deploymentInfo.signerAddress,\n  });\n  if (balance < deploymentInfo.valueToSend) {\n    const transaction = prepareTransaction({\n      chain,\n      client,\n      to: deploymentInfo.signerAddress,\n      value: deploymentInfo.valueToSend,\n    });\n    const res = await sendTransaction({ transaction, account });\n    await waitForReceipt(res);\n  }\n  const transactionHash = await eth_sendRawTransaction(\n    rpcRequest,\n    deploymentInfo.transaction,\n  );\n  return {\n    transactionHash,\n  };\n}\n\n/**\n * Retrieves the deployment information for the Create2 factory contract.\n * @param chainId - The chain ID.\n * @param gasOptions - The gas options for the deployment transaction.\n * @returns The deployment information, including the deployment transaction and the create2 factory address.\n * @internal\n */\nasync function _getCreate2FactoryDeploymentInfo(\n  chainId: number,\n  gasOptions: { gasPrice?: bigint; gasLimit?: bigint },\n) {\n  // 100000 is default deployment gas limit and 100 gwei is default gas price for create2 factory deployment\n  // (See: https://github.com/Arachnid/deterministic-deployment-proxy?tab=readme-ov-file#deployment-gas-limit)\n  const gasPrice = gasOptions.gasPrice ? gasOptions.gasPrice : 100n * 10n ** 9n;\n  const gas = gasOptions.gasLimit ? gasOptions.gasLimit : 100000n;\n  const deploymentTransaction = await getKeylessTransaction({\n    transaction: {\n      gasPrice,\n      gas,\n      nonce: 0,\n      data: CREATE2_FACTORY_BYTECODE,\n      chainId: chainId !== 0 ? Number(chainId) : undefined,\n    },\n    signature: SIGNATURE,\n  });\n  const create2FactoryAddress = getContractAddress({\n    from: deploymentTransaction.signerAddress,\n    nonce: 0n,\n  });\n\n  return {\n    ...deploymentTransaction,\n    valueToSend: gasPrice * gas,\n    predictedAddress: create2FactoryAddress,\n  };\n}\n\nfunction _getNearestGasPriceBin(gasPrice: bigint): bigint {\n  return CUSTOM_GAS_BINS.find((e) => e >= gasPrice) || gasPrice;\n}\n\n// TODO: move this somewhere else\ntype CustomChain = {\n  name: string;\n  gasPrice?: bigint;\n  gasLimit?: bigint;\n};\n\nconst CUSTOM_GAS_FOR_CHAIN: Record<string, CustomChain> = {\n  \"5001\": {\n    name: \"Mantle Testnet\",\n    gasPrice: 1n,\n  },\n  \"71402\": {\n    name: \"Godwoken Mainnet\",\n    gasPrice: 40000n * 10n ** 9n,\n  },\n  \"1351057110\": {\n    name: \"Chaos (SKALE Testnet)\",\n    gasPrice: 100000n,\n  },\n  \"361\": {\n    name: \"Theta Mainnet\",\n    gasPrice: 4000n * 10n ** 9n,\n  },\n  \"365\": {\n    name: \"Theta Testnet\",\n    gasPrice: 4000n * 10n ** 9n,\n  },\n  \"7700\": {\n    name: \"Canto\",\n    gasPrice: 1000n * 10n ** 9n,\n  },\n  \"7701\": {\n    name: \"Canto Testnet\",\n    gasPrice: 1000n * 10n ** 9n,\n  },\n  \"338\": {\n    name: \"Cronos Testnet\",\n    gasPrice: 2000n * 10n ** 9n,\n  },\n  \"199\": {\n    name: \"BitTorrent Chain\",\n    gasPrice: 300000n * 10n ** 9n,\n  },\n  \"88882\": {\n    name: \"Spicy Chain\",\n    gasPrice: 2500n * 10n ** 9n,\n    gasLimit: 200000n,\n  },\n  \"88888\": {\n    name: \"Chiliz Chain\",\n    gasPrice: 2500n * 10n ** 9n,\n    gasLimit: 200000n,\n  },\n};\n\nconst CUSTOM_GAS_BINS = [\n  1n,\n  1n * 10n ** 9n,\n  100n * 10n ** 9n,\n  500n * 10n ** 9n,\n  1000n * 10n ** 9n,\n  2500n * 10n ** 9n,\n  5000n * 10n ** 9n,\n  7500n * 10n ** 9n,\n  10_000n * 10n ** 9n,\n  25_000n * 10n ** 9n,\n  50_000n * 10n ** 9n,\n  75_000n * 10n ** 9n,\n  100_000n * 10n ** 9n,\n  250_000n * 10n ** 9n,\n  500_000n * 10n ** 9n,\n  750_000n * 10n ** 9n,\n  1_000_000n * 10n ** 9n,\n];\n", "import type { Hex } from \"../encoding/hex.js\";\nimport { stringToBytes } from \"../encoding/to-bytes.js\";\nimport { keccak256 } from \"../hashing/keccak256.js\";\n\n/**\n * Calculates the keccak ID of the given input.\n * @param input - The input value to calculate the keccak ID for.\n * @returns The keccak ID as a Hex string.\n * @example\n * ```ts\n * import { keccackId } from \"thirdweb/utils\";\n * const keccakId = keccackId(input);\n * ```\n * @utils\n */\nexport function keccakId(input: string): Hex {\n  return keccak256(stringToBytes(input));\n}\n", "import { ensureBytecodePrefix } from \"../bytecode/prefix.js\";\nimport type { Hex } from \"../encoding/hex.js\";\n\nimport { keccakId } from \"./keccak-id.js\";\n\n/**\n * Calculates the salt hash for a given bytecode.\n * @param bytecode - The bytecode to calculate the salt hash for.\n * @returns The salt hash of the bytecode.\n * @example\n * ```ts\n * import { getSaltHash } from \"thirdweb\";\n * const saltHash = getSaltHash(bytecode);\n * ```\n * @utils\n */\nexport function getSaltHash(bytecode: string): Hex {\n  const bytecodeHash = keccakId(ensureBytecodePrefix(bytecode));\n  const salt = `tw.${bytecodeHash}`;\n  return keccakId(salt);\n}\n", "import { type Hex, encodePacked } from \"viem\";\nimport { ensureBytecodePrefix } from \"../bytecode/prefix.js\";\nimport { keccak256 } from \"../hashing/keccak256.js\";\nimport { getSaltHash } from \"./get-salt-hash.js\";\nimport { keccakId } from \"./keccak-id.js\";\n\ntype ComputeDeploymentAddressOptions = {\n  bytecode: string;\n  encodedArgs: Hex;\n  create2FactoryAddress: string;\n  salt?: string;\n};\n\n/**\n * Computes the deployment address for a contract based on the given options.\n * @param options - The options for computing the deployment address.\n * @returns The computed deployment address.\n * @example\n * ```ts\n * import { computeDeploymentAddress } from \"thirdweb/utils\";\n * const deploymentAddress = computeDeploymentAddress({\n *  bytecode,\n *  encodedArgs,\n *  create2FactoryAddress,\n *  salt,\n * });\n * ```\n * @utils\n */\nexport function computeDeploymentAddress(\n  options: ComputeDeploymentAddressOptions,\n) {\n  const bytecode = ensureBytecodePrefix(options.bytecode);\n  const saltHash = options.salt\n    ? keccakId(options.salt)\n    : getSaltHash(bytecode);\n\n  // 1. create init bytecode hash with contract's bytecode and encoded args\n  const initBytecode = encodePacked(\n    [\"bytes\", \"bytes\"],\n    [bytecode, options.encodedArgs],\n  );\n\n  // 2. abi-encode pack the deployer address, salt, and bytecode hash\n  const deployInfoPacked = encodePacked(\n    [\"bytes1\", \"address\", \"bytes32\", \"bytes32\"],\n    [\n      \"0xff\",\n      options.create2FactoryAddress,\n      saltHash,\n      keccak256(encodePacked([\"bytes\"], [initBytecode])),\n    ],\n  );\n\n  // 3. hash the packed deploy info\n  const hashedDeployInfo = keccak256(\n    encodePacked([\"bytes\"], [deployInfoPacked]),\n  );\n\n  // 4. return last 20 bytes (40 characters) of the hash -- this is the predicted address\n  return `0x${hashedDeployInfo.slice(26)}`;\n}\n", "import { encodePacked } from \"viem/utils\";\nimport { ensureBytecodePrefix } from \"../bytecode/prefix.js\";\nimport { type Hex, uint8ArrayToHex } from \"../encoding/hex.js\";\nimport { getSaltHash } from \"./get-salt-hash.js\";\nimport { keccakId } from \"./keccak-id.js\";\n\ntype GetInitiBytecodeWithSaltOptions = {\n  bytecode: string;\n  encodedArgs: Hex | Uint8Array;\n  salt?: string;\n};\n\n/**\n * Generates the initialization bytecode with salt for a contract deployment.\n * @param options - The options for generating the initialization bytecode.\n * @returns The initialization bytecode with salt.\n * @example\n * ```ts\n * import { getInitBytecodeWithSalt } from \"thirdweb/utils\";\n * const initBytecodeWithSalt = getInitBytecodeWithSalt({\n *  bytecode,\n *  encodedArgs,\n *  salt,\n * });\n * ```\n * @utils\n */\nexport function getInitBytecodeWithSalt(\n  options: GetInitiBytecodeWithSaltOptions,\n): Hex {\n  const bytecode = ensureBytecodePrefix(options.bytecode);\n  const saltHash = options.salt\n    ? keccakId(options.salt)\n    : getSaltHash(bytecode);\n\n  const encodedArgs =\n    typeof options.encodedArgs === \"string\"\n      ? options.encodedArgs\n      : uint8ArrayToHex(options.encodedArgs);\n\n  return encodePacked(\n    [\"bytes32\", \"bytes\", \"bytes\"],\n    [saltHash, bytecode, encodedArgs],\n  );\n}\n", "const function_cache = new Map<string, string>();\nconst event_cache = new Map<string, string>();\n\ntype FunctionString = `function ${string}`;\ntype EventString = `event ${string}`;\n\n// TODO: investigate a better source for this\nconst SIGNATURE_API = \"https://www.4byte.directory/api/v1\";\n\nasync function resolveFunctionSignature(\n  hexSig: string,\n): Promise<FunctionString | null> {\n  if (function_cache.has(hexSig)) {\n    return function_cache.get(hexSig) as FunctionString;\n  }\n  const res = await fetch(\n    `${SIGNATURE_API}/signatures/?format=json&hex_signature=${hexSig}`,\n  );\n  if (!res.ok) {\n    res.body?.cancel();\n    return null;\n  }\n  const data = await res.json();\n  if (data.count === 0) {\n    return null;\n  }\n  const signature = `function ${data.results[0].text_signature}` as const;\n  function_cache.set(hexSig, signature);\n  return signature;\n}\n\nasync function resolveEventSignature(\n  hexSig: string,\n): Promise<EventString | null> {\n  if (event_cache.has(hexSig)) {\n    return event_cache.get(hexSig) as EventString;\n  }\n  const res = await fetch(\n    `${SIGNATURE_API}/event-signatures/?format=json&hex_signature=${hexSig}`,\n  );\n  if (!res.ok) {\n    res.body?.cancel();\n    return null;\n  }\n  const data = await res.json();\n  if (data.count === 0) {\n    return null;\n  }\n\n  const signature = `event ${uppercaseFirstLetter(\n    data.results[0].text_signature,\n  )}` as const;\n  event_cache.set(hexSig, signature);\n  return signature;\n}\n// helper\nfunction uppercaseFirstLetter(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n/**\n * Resolves a signature by converting a hexadecimal string into a function or event signature.\n * @param hexSig The hexadecimal signature to resolve.\n * @returns A promise that resolves to an object containing the function and event signatures.\n * @example\n * ```ts\n * import { resolveSignature } from \"thirdweb/utils\";\n * const res = await resolveSignature(\"0x1f931c1c\");\n * console.log(res);\n * ```\n * @utils\n */\nexport async function resolveSignature(hexSig: string): Promise<{\n  function: FunctionString | null;\n  event: EventString | null;\n}> {\n  if (hexSig.startsWith(\"0x\")) {\n    // biome-ignore lint/style/noParameterAssign: modifying in-place for performance\n    hexSig = hexSig.slice(2);\n  }\n  const all = await Promise.all([\n    resolveFunctionSignature(hexSig),\n    resolveEventSignature(hexSig),\n  ]);\n  return {\n    function: all[0],\n    event: all[1],\n  };\n}\n\n/**\n * Resolves the signatures of the given hexadecimal signatures.\n * @param hexSigs An array of hexadecimal signatures.\n * @returns A promise that resolves to an object containing the resolved functions and events.\n * @example\n * ```ts\n * import { resolveSignatures } from \"thirdweb/utils\";\n * const res = await resolveSignatures([\"0x1f931c1c\", \"0x1f931c1c\"]);\n * console.log(res);\n * ```\n * @utils\n */\nexport async function resolveSignatures(hexSigs: string[]): Promise<{\n  functions: FunctionString[];\n  events: EventString[];\n}> {\n  // dedupe hexSigs\n  // biome-ignore lint/style/noParameterAssign: modifying in-place for performance\n  hexSigs = Array.from(new Set(hexSigs));\n  const all = await Promise.all(\n    hexSigs.map((hexSig) => resolveSignature(hexSig)),\n  );\n  return {\n    functions: all\n      .map((x) => x.function)\n      .filter((x) => x !== null)\n      .sort() as FunctionString[],\n    events: all\n      .map((x) => x.event)\n      .filter((x) => x !== null)\n      .sort() as EventString[],\n  };\n}\n\n/**\n * @internal\n */\nexport function clearCache() {\n  function_cache.clear();\n  event_cache.clear();\n}\n", "/**\n * This is a precompile of the header for the JWT generated via:\n * ```ts\n * uint8ArrayToBase64(\n * stringToBytes(JSON.stringify(RAW_HEADER)),\n * )\n * ```\n */\nexport const PRECOMPILED_B64_ENCODED_JWT_HEADER =\n  \"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9\";\n", "import type { Hex } from \"../encoding/hex.js\";\nimport { base64ToString } from \"../uint8-array.js\";\nimport { PRECOMPILED_B64_ENCODED_JWT_HEADER } from \"./jwt-header.js\";\nimport type { JWTPayload } from \"./types.js\";\n\n/**\n * Decodes a JSON Web Token (JWT) and returns the decoded payload and signature.\n * @param jwt - The JWT string to decode.\n * @returns An object containing the decoded payload and signature.\n * @throws {Error} If the JWT header is invalid or if the JWT is invalid.\n * @example\n * ```ts\n * import { decodeJWT } from 'thirdweb/utils';\n *\n * const { payload, signature } = decodeJWT(jwt);\n * ```\n * @auth\n */\nexport function decodeJWT(jwt: string) {\n  const [encodedHeader, encodedPayload, encodedSignature] = jwt.split(\".\");\n\n  if (encodedHeader !== PRECOMPILED_B64_ENCODED_JWT_HEADER) {\n    throw new Error(\"Invalid JWT header\");\n  }\n  if (!encodedPayload || !encodedSignature) {\n    throw new Error(\"Invalid JWT\");\n  }\n\n  const payload: JWTPayload = JSON.parse(base64ToString(encodedPayload));\n  const signature = base64ToString(encodedSignature) as Hex;\n\n  return {\n    payload,\n    signature,\n  };\n}\n", "import type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport { stringToBytes } from \"../encoding/to-bytes.js\";\nimport { randomBytesHex } from \"../random.js\";\nimport { uint8ArrayToBase64 } from \"../uint8-array.js\";\nimport { PRECOMPILED_B64_ENCODED_JWT_HEADER } from \"./jwt-header.js\";\nimport type { JWTPayload } from \"./types.js\";\n\nexport type JWTPayloadInput<Tctx = unknown> = {\n  iss: string;\n  sub: string;\n  aud: string;\n  exp: Date;\n  nbf: Date;\n  iat: Date;\n  jti?: string;\n  ctx?: Tctx;\n};\n\ntype EncodeJWTParams = { payload: JWTPayloadInput; account: Account };\n\n/**\n * Builds a JSON Web Token (JWT) using the provided options.\n * @param options - The options for building the JWT.\n * @returns The generated JWT.\n * @throws Error if the account is not found.\n * @example\n * ```ts\n * import { encodeJWT } from 'thirdweb/utils';\n *\n * const jwt = await encodeJWT({\n *  payload: {\n *    iss: '0x1234567890123456789012345678901234567890',\n *    sub: '0x1234567890123456789012345678901234567890',\n *    aud: '0x1234567890123456789012345678901234567890',\n *    exp: new Date(Date.now() + 1000 * 60 * 60),\n *    nbf: new Date(),\n *    iat: new Date(),\n *    jti: '1234567890',\n *    ctx: {\n *        example: 'example',\n *    },\n *  },\n *  wallet,\n * });\n * ```\n * @auth\n */\nexport async function encodeJWT(options: EncodeJWTParams) {\n  const payload = await ensureJWTPayload(options.payload);\n  const message = JSON.stringify(payload);\n\n  const signature = await options.account.signMessage({ message });\n\n  const encodedData = uint8ArrayToBase64(\n    stringToBytes(JSON.stringify(payload)),\n    { urlSafe: true },\n  );\n\n  const encodedSignature = uint8ArrayToBase64(stringToBytes(signature), {\n    urlSafe: true,\n  });\n\n  // Generate a JWT with base64 encoded header, payload, and signature\n  return `${PRECOMPILED_B64_ENCODED_JWT_HEADER}.${encodedData}.${encodedSignature}`;\n}\n\nasync function ensureJWTPayload(payload: JWTPayloadInput): Promise<JWTPayload> {\n  return {\n    iss: payload.iss,\n    sub: payload.sub,\n    aud: payload.aud,\n    exp: Math.floor(payload.exp.getTime() / 1000),\n    nbf: Math.floor(payload.nbf.getTime() / 1000),\n    iat: Math.floor(payload.iat.getTime() / 1000),\n    // default to uuid if jti is not provided\n    jti: payload.jti || (await randomBytesHex()),\n    ctx: payload.ctx,\n  };\n}\n", "import type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport { decodeJWT } from \"./decode-jwt.js\";\nimport { encodeJWT } from \"./encode-jwt.js\";\n\nconst DEFAULT_EXPIRATION_TIME = 60 * 60 * 24;\n\nexport type RefreshJWTParams = {\n  account: Account;\n  jwt: string;\n  expirationTime?: number;\n};\n\n/**\n * Refreshes a JSON Web Token (JWT) by encoding a new payload with updated expiration time.\n * @param options - The options for refreshing the JWT.\n * @returns A Promise that resolves to the refreshed JWT.\n * @example\n * ```ts\n * import { refreshJWT } from 'thirdweb/utils';\n *\n * const jwt = await refreshJWT({\n *  account,\n *  jwt,\n *  expirationTime: 1000 * 60 * 60,\n * });\n * ```\n * @auth\n */\nexport async function refreshJWT(options: RefreshJWTParams): Promise<string> {\n  const { account, jwt, expirationTime = DEFAULT_EXPIRATION_TIME } = options;\n  const payload = decodeJWT(jwt).payload;\n  return encodeJWT({\n    payload: {\n      iss: payload.iss,\n      sub: payload.sub,\n      aud: payload.aud,\n      nbf: new Date(),\n      exp: new Date(Date.now() + expirationTime),\n      iat: new Date(),\n      ctx: payload.ctx,\n    },\n    account,\n  });\n}\n", "import { isAddress } from \"../address.js\";\nimport { isHex, padHex } from \"../encoding/hex.js\";\n\n/**\n * Converts an array of parameter values to their respective types based on the provided type array.\n *\n * This utility function is particularly useful for ensuring that parameter values are correctly formatted\n * according to the expected types before they are used in further processing or passed to a Solidity smart contract.\n *\n * @param {string[]} constructorParamTypes - An array of type strings indicating the expected types of the values,\n *                   following Solidity type conventions (e.g., \"address\", \"uint256\", \"bool\").\n * @param {unknown[]} constructorParamValues - An array of values to be converted according to the types.\n * @returns - An array of values converted to their respective types.\n *\n * @example\n * ```ts\n * import { parseAbiParams } from \"thirdweb/utils\";\n *\n * const example1 = parseAbiParams(\n *   [\"address\", \"uint256\"],\n *   [\"0x.....\", \"1200000\"]\n * ); // result: [\"0x......\", 1200000n]\n *\n * const example2 = parseAbiParams(\n *   [\"address\", \"bool\"],\n *   [\"0x.....\", \"true\"]\n * ); // result: [\"0x......\", true]\n * ```\n * @utils\n */\nexport function parseAbiParams(\n  constructorParamTypes: string[],\n  constructorParamValues: unknown[],\n): Array<string | bigint | boolean> {\n  /**\n   * Internal Solidity type checklist\n   * 1. tuple, array -> JSON.parse | todo: Recursively parse the content\n   * 2. uint, int -> bigint\n   * 3. address -> string\n   * 4. string -> string\n   * 5. bytes, bytes32 etc. -> string\n   * 6. bool -> boolean\n   * >>> Make sure to return the original value at the end of the function <<<\n   */\n\n  // Make sure they have the same length\n  if (constructorParamTypes.length !== constructorParamValues.length) {\n    throw new Error(\n      `Passed the wrong number of constructor arguments: ${constructorParamValues.length}, expected ${constructorParamTypes.length}`,\n    );\n  }\n  return constructorParamTypes.map((type, index) => {\n    const value = constructorParamValues[index];\n    if (type === \"tuple\" || type.endsWith(\"[]\")) {\n      if (typeof value === \"string\") {\n        return JSON.parse(value);\n      }\n      return value;\n    }\n    if (type === \"string\") {\n      return String(value);\n    }\n    if (type === \"bytes32\") {\n      if (!isHex(value)) {\n        throw new Error(`${value} is not a valid hex string`);\n      }\n      return padHex(value);\n    }\n    if (type.startsWith(\"bytes\")) {\n      if (!isHex(value)) {\n        throw new Error(`${value} is not a valid hex string`);\n      }\n      return value;\n    }\n    if (type === \"address\") {\n      if (typeof value !== \"string\" || !isAddress(value)) {\n        throw new Error(`${value} is not a valid address`);\n      }\n      return value;\n    }\n    if (type.startsWith(\"uint\") || type.startsWith(\"int\")) {\n      if (typeof value === \"bigint\") {\n        return value;\n      }\n      if (typeof value !== \"string\" && typeof value !== \"number\") {\n        throw new Error(`Cannot convert type ${typeof value} to BigInt`);\n      }\n      try {\n        const val = BigInt(value);\n        return val;\n      } catch (err) {\n        throw new Error((err as Error).message);\n      }\n    }\n    if (type.startsWith(\"bool\")) {\n      if (value === \"false\" || value === false) {\n        return false;\n      }\n      if (value === \"true\" || value === true) {\n        return true;\n      }\n      throw new Error(\n        \"Invalid boolean value. Expecting either 'true' or 'false'\",\n      );\n    }\n\n    // Return the value here if none of the types match\n    return value;\n  });\n}\n"],
  "mappings": "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",
  "names": ["enforceEip155", "eipChain", "deploymentInfo"]
}
