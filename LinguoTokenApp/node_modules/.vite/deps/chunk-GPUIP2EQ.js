import {
  assertSize,
  hexToBigInt,
  hexToNumber,
  hexToUint8Array,
  isHex,
  uint8ArrayToHex
} from "./chunk-HBHEB2SD.js";
import {
  sha256
} from "./chunk-DZWKJ2HW.js";

// node_modules/thirdweb/dist/esm/utils/encoding/helpers/trim.js
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0; i < data.length - 1; i++) {
    if (data[dir === "left" ? i : data.length - i - 1].toString() === "0") {
      sliceLength++;
    } else {
      break;
    }
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right") {
      data = `${data}0`;
    }
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}

// node_modules/thirdweb/dist/esm/utils/encoding/from-bytes.js
function fromBytes(bytes, toOrOpts) {
  const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
  switch (opts.to) {
    case "number":
      return bytesToNumber(bytes, opts);
    case "bigint":
      return bytesToBigInt(bytes, opts);
    case "boolean":
      return bytesToBool(bytes, opts);
    case "string":
      return bytesToString(bytes, opts);
    default:
      return uint8ArrayToHex(bytes, opts);
  }
}
function bytesToBigInt(bytes, opts = {}) {
  if (typeof opts.size !== "undefined") {
    assertSize(bytes, { size: opts.size });
  }
  const hex = uint8ArrayToHex(bytes, opts);
  return hexToBigInt(hex, opts);
}
function bytesToBool(bytes_, opts = {}) {
  let bytes = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes, { size: opts.size });
    bytes = trim(bytes);
  }
  if (bytes.length > 1 || bytes[0] && bytes[0] > 1) {
    throw new Error(`Invalid boolean representation: ${bytes}`);
  }
  return Boolean(bytes[0]);
}
function bytesToNumber(bytes, opts = {}) {
  if (typeof opts.size !== "undefined") {
    assertSize(bytes, { size: opts.size });
  }
  const hex = uint8ArrayToHex(bytes, opts);
  return hexToNumber(hex, opts);
}
function bytesToString(bytes_, opts = {}) {
  let bytes = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes, { size: opts.size });
    bytes = trim(bytes, { dir: "right" });
  }
  return new TextDecoder().decode(bytes);
}

// node_modules/thirdweb/dist/esm/utils/hashing/sha256.js
function sha2562(value, to) {
  const bytes = sha256(isHex(value, { strict: false }) ? hexToUint8Array(value) : value);
  if (to === "bytes") {
    return bytes;
  }
  return uint8ArrayToHex(bytes);
}

export {
  fromBytes,
  bytesToBigInt,
  bytesToBool,
  bytesToNumber,
  bytesToString,
  sha2562 as sha256
};
//# sourceMappingURL=chunk-GPUIP2EQ.js.map
