import {
  isEcosystemWallet
} from "./chunk-Q35Y75F4.js";
import {
  createInAppWallet
} from "./chunk-4R6CAGL5.js";
import {
  webLocalStorage
} from "./chunk-57DFWRZ3.js";
import {
  smartWallet
} from "./chunk-AUVKPJDE.js";
import {
  createWalletEmitter,
  trackConnect
} from "./chunk-2S6BBZVH.js";
import {
  getCoinbaseWebProvider
} from "./chunk-4BC3YJ6S.js";
import {
  COINBASE
} from "./chunk-LZH3KM55.js";
import {
  getCachedChainIfExists
} from "./chunk-TQTA6FSB.js";
import {
  detectOS
} from "./chunk-3OXDSLPJ.js";

// node_modules/thirdweb/dist/esm/wallets/in-app/web/ecosystem.js
function ecosystemWallet(...args) {
  const [ecosystemId, createOptions] = args;
  const ecosystem = {
    id: ecosystemId,
    partnerId: createOptions == null ? void 0 : createOptions.partnerId
  };
  return createInAppWallet({
    ecosystem,
    createOptions: {
      auth: {
        ...createOptions == null ? void 0 : createOptions.auth,
        options: []
        // controlled by ecosystem
      },
      partnerId: ecosystem.partnerId
    },
    connectorFactory: async (client) => {
      const { InAppWebConnector } = await import("./web-connector-JENTNVFG.js");
      return new InAppWebConnector({
        client,
        ecosystem
      });
    }
  });
}

// node_modules/thirdweb/dist/esm/wallets/in-app/web/in-app.js
function inAppWallet(createOptions) {
  return createInAppWallet({
    createOptions,
    connectorFactory: async (client) => {
      var _a;
      const { InAppWebConnector } = await import("./web-connector-JENTNVFG.js");
      return new InAppWebConnector({
        client,
        passkeyDomain: (_a = createOptions == null ? void 0 : createOptions.auth) == null ? void 0 : _a.passkeyDomain
      });
    }
  });
}

// node_modules/thirdweb/dist/esm/utils/web/isMobile.js
function isAndroid() {
  if (typeof navigator === "undefined") {
    return false;
  }
  const os = detectOS(navigator.userAgent);
  return os ? os.toLowerCase().includes("android") : false;
}
function isIOS() {
  if (typeof navigator === "undefined") {
    return false;
  }
  const os = detectOS(navigator.userAgent);
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  return isAndroid() || isIOS();
}

// node_modules/thirdweb/dist/esm/utils/web/openWindow.js
function openWindow(uri) {
  const isInsideIframe = window !== window.top;
  if (isInsideIframe) {
    window.open(uri);
  } else {
    if (uri.startsWith("http")) {
      const link = document.createElement("a");
      link.href = uri;
      link.target = "_blank";
      link.rel = "noreferrer noopener";
      link.click();
    } else {
      window.location.href = uri;
    }
  }
}

// node_modules/thirdweb/dist/esm/wallets/coinbase/coinbase-wallet.js
function coinbaseWalletSDK(args) {
  const { createOptions } = args;
  const emitter = createWalletEmitter();
  let account = void 0;
  let chain = void 0;
  function reset() {
    account = void 0;
    chain = void 0;
  }
  let handleDisconnect = async () => {
  };
  let handleSwitchChain = async (newChain) => {
    chain = newChain;
  };
  const unsubscribeChainChanged = emitter.subscribe("chainChanged", (newChain) => {
    chain = newChain;
  });
  const unsubscribeDisconnect = emitter.subscribe("disconnect", () => {
    reset();
    unsubscribeChainChanged();
    unsubscribeDisconnect();
  });
  emitter.subscribe("accountChanged", (_account) => {
    account = _account;
  });
  return {
    id: COINBASE,
    subscribe: emitter.subscribe,
    getChain() {
      if (!chain) {
        return void 0;
      }
      chain = getCachedChainIfExists(chain.id) || chain;
      return chain;
    },
    getConfig: () => createOptions,
    getAccount: () => account,
    autoConnect: async (options) => {
      const { autoConnectCoinbaseWalletSDK } = await import("./coinbaseWebSDK-LFPR2EZ4.js");
      const provider = await args.providerFactory();
      const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await autoConnectCoinbaseWalletSDK(options, emitter, provider);
      account = connectedAccount;
      chain = connectedChain;
      handleDisconnect = doDisconnect;
      handleSwitchChain = doSwitchChain;
      trackConnect({
        client: options.client,
        walletType: COINBASE,
        walletAddress: account.address
      });
      return account;
    },
    connect: async (options) => {
      const { connectCoinbaseWalletSDK } = await import("./coinbaseWebSDK-LFPR2EZ4.js");
      const provider = await args.providerFactory();
      const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await connectCoinbaseWalletSDK(options, emitter, provider);
      account = connectedAccount;
      chain = connectedChain;
      handleDisconnect = doDisconnect;
      handleSwitchChain = doSwitchChain;
      trackConnect({
        client: options.client,
        walletType: COINBASE,
        walletAddress: account.address
      });
      return account;
    },
    disconnect: async () => {
      reset();
      await handleDisconnect();
    },
    switchChain: async (newChain) => {
      await handleSwitchChain(newChain);
    },
    onConnectRequested: async () => {
      var _a;
      if (args.onConnectRequested) {
        const provider = await args.providerFactory();
        return (_a = args.onConnectRequested) == null ? void 0 : _a.call(args, provider);
      }
    }
  };
}

// node_modules/thirdweb/dist/esm/wallets/create-wallet.js
function createWallet(...args) {
  const [id, creationOptions] = args;
  switch (true) {
    case id === "smart": {
      return smartWallet(creationOptions);
    }
    case (id === "embedded" || id === "inApp"): {
      return inAppWallet(creationOptions);
    }
    case isEcosystemWallet(id):
      return ecosystemWallet(...args);
    case id === COINBASE: {
      const options = creationOptions;
      return coinbaseWalletSDK({
        createOptions: options,
        providerFactory: () => getCoinbaseWebProvider(options),
        onConnectRequested: async (provider) => {
          const { showCoinbasePopup } = await import("./utils-ZWAKIS3M.js");
          return showCoinbasePopup(provider);
        }
      });
    }
    default: {
      let reset = function() {
        account = void 0;
        chain = void 0;
      };
      const emitter = createWalletEmitter();
      let account = void 0;
      let chain = void 0;
      const unsubscribeChain = emitter.subscribe("chainChanged", (newChain) => {
        chain = newChain;
      });
      let handleDisconnect = async () => {
      };
      const unsubscribeDisconnect = emitter.subscribe("disconnect", () => {
        reset();
        unsubscribeChain();
        unsubscribeDisconnect();
      });
      emitter.subscribe("accountChanged", (_account) => {
        account = _account;
      });
      let handleSwitchChain = async () => {
        throw new Error("Not implemented yet");
      };
      const sessionHandler = isMobile() ? (uri) => openWindow(uri) : void 0;
      const wallet = {
        id,
        subscribe: emitter.subscribe,
        getConfig: () => args[1],
        getChain() {
          if (!chain) {
            return void 0;
          }
          chain = getCachedChainIfExists(chain.id) || chain;
          return chain;
        },
        getAccount: () => account,
        autoConnect: async (options) => {
          const { injectedProvider } = await import("./mipdStore-LMXLDWSL.js");
          if (id !== "walletConnect" && injectedProvider(id)) {
            const { autoConnectInjectedWallet } = await import("./injected-4L3R6HX2.js");
            const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await autoConnectInjectedWallet(id, emitter, options.chain);
            account = connectedAccount;
            chain = connectedChain;
            handleDisconnect = doDisconnect;
            handleSwitchChain = doSwitchChain;
            trackConnect({
              client: options.client,
              walletType: id,
              walletAddress: account.address
            });
            return account;
          }
          if (options && "client" in options) {
            const { autoConnectWC } = await import("./controller-WYWQHU4F.js");
            const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await autoConnectWC(options, emitter, wallet.id, webLocalStorage, sessionHandler);
            account = connectedAccount;
            chain = connectedChain;
            handleDisconnect = doDisconnect;
            handleSwitchChain = doSwitchChain;
            trackConnect({
              client: options.client,
              walletType: id,
              walletAddress: account.address
            });
            return account;
          }
          throw new Error("Failed to auto connect");
        },
        connect: async (options) => {
          async function wcConnect(wcOptions) {
            const { connectWC } = await import("./controller-WYWQHU4F.js");
            const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await connectWC(wcOptions, emitter, wallet.id, webLocalStorage, sessionHandler);
            account = connectedAccount;
            chain = connectedChain;
            handleDisconnect = doDisconnect;
            handleSwitchChain = doSwitchChain;
            trackConnect({
              client: wcOptions.client,
              walletType: id,
              walletAddress: account.address
            });
            return account;
          }
          if (id === "walletConnect") {
            const { client, chain: _chain, ...walletConnectOptions } = options;
            return wcConnect({
              client,
              chain: _chain,
              walletConnect: {
                ...walletConnectOptions
              }
            });
          }
          const forceWalletConnectOption = options && "walletConnect" in options;
          const { injectedProvider } = await import("./mipdStore-LMXLDWSL.js");
          if (injectedProvider(id) && !forceWalletConnectOption) {
            const { connectInjectedWallet } = await import("./injected-4L3R6HX2.js");
            const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await connectInjectedWallet(id, options, emitter);
            account = connectedAccount;
            chain = connectedChain;
            handleDisconnect = doDisconnect;
            handleSwitchChain = doSwitchChain;
            trackConnect({
              client: options.client,
              walletType: id,
              walletAddress: account.address
            });
            return account;
          }
          if (options && "client" in options) {
            return wcConnect(options);
          }
          throw new Error("Failed to connect");
        },
        // these get overridden in connect and autoConnect
        disconnect: async () => {
          reset();
          await handleDisconnect();
        },
        switchChain: (c) => handleSwitchChain(c)
      };
      return wallet;
    }
  }
}
function walletConnect() {
  return createWallet("walletConnect");
}

export {
  isAndroid,
  isIOS,
  isMobile,
  openWindow,
  ecosystemWallet,
  inAppWallet,
  createWallet,
  walletConnect
};
//# sourceMappingURL=chunk-QSV2COCK.js.map
