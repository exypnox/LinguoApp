{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/encoding/helpers/trim.ts", "../../thirdweb/src/utils/encoding/from-bytes.ts", "../../thirdweb/src/utils/hashing/sha256.ts"],
  "sourcesContent": ["import type { Hex } from \"./is-hex.js\";\n\ntype TrimOptions = {\n  dir?: \"left\" | \"right\";\n};\ntype TrimReturnType<TValue extends Uint8Array | Hex> = TValue extends Hex\n  ? Hex\n  : Uint8Array;\n\n/**\n * Trims leading or trailing zeros from a hexadecimal string or byte array.\n *\n * @param hexOrBytes - The hexadecimal string or byte array to trim.\n * @param options - The options for trimming. Default is to trim leading zeros.\n * @returns The trimmed hexadecimal string or byte array.\n * @internal\n */\nexport function trim<TValue extends Uint8Array | Hex>(\n  hexOrBytes: TValue,\n  { dir = \"left\" }: TrimOptions = {},\n): TrimReturnType<TValue> {\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  let data: any =\n    typeof hexOrBytes === \"string\" ? hexOrBytes.replace(\"0x\", \"\") : hexOrBytes;\n\n  let sliceLength = 0;\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === \"left\" ? i : data.length - i - 1].toString() === \"0\") {\n      sliceLength++;\n    } else {\n      break;\n    }\n  }\n  data =\n    dir === \"left\"\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength);\n\n  if (typeof hexOrBytes === \"string\") {\n    if (data.length === 1 && dir === \"right\") {\n      data = `${data}0`;\n    }\n    return `0x${\n      data.length % 2 === 1 ? `0${data}` : data\n    }` as TrimReturnType<TValue>;\n  }\n  return data as TrimReturnType<TValue>;\n}\n", "import { assertSize } from \"./helpers/assert-size.js\";\nimport type { Hex } from \"./helpers/is-hex.js\";\nimport { trim } from \"./helpers/trim.js\";\nimport { hexToBigInt, hexToNumber, uint8ArrayToHex } from \"./hex.js\";\n\nexport type FromBytesParameters<\n  TTo extends \"string\" | \"hex\" | \"bigint\" | \"number\" | \"boolean\",\n> =\n  | TTo\n  | {\n      /** Size of the bytes. */\n      size?: number;\n      /** Type to convert to. */\n      to: TTo;\n    };\n\nexport type FromBytesReturnType<TTo> = TTo extends \"string\"\n  ? string\n  : TTo extends \"hex\"\n    ? Hex\n    : TTo extends \"bigint\"\n      ? bigint\n      : TTo extends \"number\"\n        ? number\n        : TTo extends \"boolean\"\n          ? boolean\n          : never;\n\n/**\n * Converts a Uint8Array to the specified type.\n * @param bytes - The Uint8Array to convert.\n * @param toOrOpts - The target type or conversion options.\n * @returns The converted value of the specified type.\n * @example\n * ```ts\n * import { fromBytes } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const number = fromBytes(bytes, \"number\");\n * console.log(number); // 420\n * ```\n * @utils\n */\nexport function fromBytes<\n  TTo extends \"string\" | \"hex\" | \"bigint\" | \"number\" | \"boolean\",\n>(\n  bytes: Uint8Array,\n  toOrOpts: FromBytesParameters<TTo>,\n): FromBytesReturnType<TTo> {\n  const opts = typeof toOrOpts === \"string\" ? { to: toOrOpts } : toOrOpts;\n  switch (opts.to) {\n    case \"number\":\n      return bytesToNumber(bytes, opts) as FromBytesReturnType<TTo>;\n    case \"bigint\":\n      return bytesToBigInt(bytes, opts) as FromBytesReturnType<TTo>;\n    case \"boolean\":\n      return bytesToBool(bytes, opts) as FromBytesReturnType<TTo>;\n    case \"string\":\n      return bytesToString(bytes, opts) as FromBytesReturnType<TTo>;\n    default:\n      return uint8ArrayToHex(bytes, opts) as FromBytesReturnType<TTo>;\n  }\n}\n\nexport type BytesToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean;\n  /** Size of the bytes. */\n  size?: number;\n};\n\n/**\n * Converts a Uint8Array of bytes to a bigint.\n * @param bytes - The Uint8Array of bytes to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The converted bigint.\n * @example\n * ```ts\n * import { bytesToBigInt } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const bigInt = bytesToBigInt(bytes);\n * console.log(bigInt); // 420n\n * ```\n * @utils\n */\nexport function bytesToBigInt(\n  bytes: Uint8Array,\n  opts: BytesToBigIntOpts = {},\n): bigint {\n  if (typeof opts.size !== \"undefined\") {\n    assertSize(bytes, { size: opts.size });\n  }\n  const hex = uint8ArrayToHex(bytes, opts);\n  return hexToBigInt(hex, opts);\n}\n\nexport type BytesToBoolOpts = {\n  /** Size of the bytes. */\n  size?: number;\n};\n\n/**\n * Converts a byte array to a boolean value.\n * @param bytes_ - The byte array to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The boolean value converted from the byte array.\n * @throws Error if the byte array is invalid or the boolean representation is invalid.\n * @example\n * ```ts\n * import { bytesToBool } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1]);\n * const bool = bytesToBool(bytes);\n * console.log(bool); // true\n * ```\n * @utils\n */\nexport function bytesToBool(\n  bytes_: Uint8Array,\n  opts: BytesToBoolOpts = {},\n): boolean {\n  let bytes = bytes_;\n  if (typeof opts.size !== \"undefined\") {\n    assertSize(bytes, { size: opts.size });\n    bytes = trim(bytes);\n  }\n\n  if (bytes.length > 1 || (bytes[0] && bytes[0] > 1)) {\n    throw new Error(`Invalid boolean representation: ${bytes}`);\n  }\n  return Boolean(bytes[0]);\n}\n\nexport type BytesToNumberOpts = BytesToBigIntOpts;\n\n/**\n * Converts a Uint8Array of bytes to a number.\n * @param bytes - The Uint8Array of bytes to convert.\n * @param opts - Optional configuration options.\n * @returns The converted number.\n * @example\n * ```ts\n * import { bytesToNumber } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const number = bytesToNumber(bytes);\n * console.log(number); // 420\n * ```\n * @utils\n */\nexport function bytesToNumber(\n  bytes: Uint8Array,\n  opts: BytesToNumberOpts = {},\n): number {\n  if (typeof opts.size !== \"undefined\") {\n    assertSize(bytes, { size: opts.size });\n  }\n  const hex = uint8ArrayToHex(bytes, opts);\n  return hexToNumber(hex, opts);\n}\n\nexport type BytesToStringOpts = {\n  /** Size of the bytes. */\n  size?: number;\n};\n\n/**\n * Converts an array of bytes to a string using UTF-8 encoding.\n * @param bytes_ - The array of bytes to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The resulting string.\n * @example\n * ```ts\n * import { bytesToString } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([72, 101, 108, 108, 111]);\n * const string = bytesToString(bytes);\n * console.log(string); // \"Hello\"\n * ```\n * @utils\n */\nexport function bytesToString(\n  bytes_: Uint8Array,\n  opts: BytesToStringOpts = {},\n): string {\n  let bytes = bytes_;\n  if (typeof opts.size !== \"undefined\") {\n    assertSize(bytes, { size: opts.size });\n    bytes = trim(bytes, { dir: \"right\" });\n  }\n  return new TextDecoder().decode(bytes);\n}\n", "import { sha256 as noble_sha256 } from \"@noble/hashes/sha256\";\nimport {\n  type Hex,\n  hexToUint8Array,\n  isHex,\n  uint8ArrayToHex,\n} from \"../encoding/hex.js\";\n\ntype To = \"hex\" | \"bytes\";\n\ntype Sha256Hash<TTo extends To> =\n  | (TTo extends \"bytes\" ? Uint8Array : never)\n  | (TTo extends \"hex\" ? Hex : never);\n\n/**\n * Calculates the SHA256 hash of the given value.\n * @param value - The value to hash. It can be either a hexadecimal string or a Uint8Array.\n * @param to - (Optional) The desired output format of the hash. Defaults to 'hex'.\n * @returns The SHA256 hash of the value in the specified format.\n * @example\n * ```ts\n * import { sha256 } from \"thirdweb/utils\";\n * const hash = sha256(\"0x1234\");\n * ```\n * @utils\n */\nexport function sha256<TTo extends To = \"hex\">(\n  value: Hex | Uint8Array,\n  to?: TTo,\n): Sha256Hash<TTo> {\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? hexToUint8Array(value) : value,\n  );\n  if (to === \"bytes\") {\n    return bytes as Sha256Hash<TTo>;\n  }\n  return uint8ArrayToHex(bytes) as Sha256Hash<TTo>;\n}\n"],
  "mappings": ";;;;;;;;;;;;;AAiBM,SAAU,KACd,YACA,EAAE,MAAM,OAAM,IAAkB,CAAA,GAAE;AAGlC,MAAI,OACF,OAAO,eAAe,WAAW,WAAW,QAAQ,MAAM,EAAE,IAAI;AAElE,MAAI,cAAc;AAClB,WAAS,IAAI,GAAG,IAAI,KAAK,SAAS,GAAG,KAAK;AACxC,QAAI,KAAK,QAAQ,SAAS,IAAI,KAAK,SAAS,IAAI,CAAC,EAAE,SAAQ,MAAO,KAAK;AACrE;IACF,OAAO;AACL;IACF;EACF;AACA,SACE,QAAQ,SACJ,KAAK,MAAM,WAAW,IACtB,KAAK,MAAM,GAAG,KAAK,SAAS,WAAW;AAE7C,MAAI,OAAO,eAAe,UAAU;AAClC,QAAI,KAAK,WAAW,KAAK,QAAQ,SAAS;AACxC,aAAO,GAAG,IAAI;IAChB;AACA,WAAO,KACL,KAAK,SAAS,MAAM,IAAI,IAAI,IAAI,KAAK,IACvC;EACF;AACA,SAAO;AACT;;;ACLM,SAAU,UAGd,OACA,UAAkC;AAElC,QAAM,OAAO,OAAO,aAAa,WAAW,EAAE,IAAI,SAAQ,IAAK;AAC/D,UAAQ,KAAK,IAAI;IACf,KAAK;AACH,aAAO,cAAc,OAAO,IAAI;IAClC,KAAK;AACH,aAAO,cAAc,OAAO,IAAI;IAClC,KAAK;AACH,aAAO,YAAY,OAAO,IAAI;IAChC,KAAK;AACH,aAAO,cAAc,OAAO,IAAI;IAClC;AACE,aAAO,gBAAgB,OAAO,IAAI;EACtC;AACF;AAuBM,SAAU,cACd,OACA,OAA0B,CAAA,GAAE;AAE5B,MAAI,OAAO,KAAK,SAAS,aAAa;AACpC,eAAW,OAAO,EAAE,MAAM,KAAK,KAAI,CAAE;EACvC;AACA,QAAM,MAAM,gBAAgB,OAAO,IAAI;AACvC,SAAO,YAAY,KAAK,IAAI;AAC9B;AAsBM,SAAU,YACd,QACA,OAAwB,CAAA,GAAE;AAE1B,MAAI,QAAQ;AACZ,MAAI,OAAO,KAAK,SAAS,aAAa;AACpC,eAAW,OAAO,EAAE,MAAM,KAAK,KAAI,CAAE;AACrC,YAAQ,KAAK,KAAK;EACpB;AAEA,MAAI,MAAM,SAAS,KAAM,MAAM,CAAC,KAAK,MAAM,CAAC,IAAI,GAAI;AAClD,UAAM,IAAI,MAAM,mCAAmC,KAAK,EAAE;EAC5D;AACA,SAAO,QAAQ,MAAM,CAAC,CAAC;AACzB;AAkBM,SAAU,cACd,OACA,OAA0B,CAAA,GAAE;AAE5B,MAAI,OAAO,KAAK,SAAS,aAAa;AACpC,eAAW,OAAO,EAAE,MAAM,KAAK,KAAI,CAAE;EACvC;AACA,QAAM,MAAM,gBAAgB,OAAO,IAAI;AACvC,SAAO,YAAY,KAAK,IAAI;AAC9B;AAqBM,SAAU,cACd,QACA,OAA0B,CAAA,GAAE;AAE5B,MAAI,QAAQ;AACZ,MAAI,OAAO,KAAK,SAAS,aAAa;AACpC,eAAW,OAAO,EAAE,MAAM,KAAK,KAAI,CAAE;AACrC,YAAQ,KAAK,OAAO,EAAE,KAAK,QAAO,CAAE;EACtC;AACA,SAAO,IAAI,YAAW,EAAG,OAAO,KAAK;AACvC;;;ACjKM,SAAUA,QACd,OACA,IAAQ;AAER,QAAM,QAAQ,OACZ,MAAM,OAAO,EAAE,QAAQ,MAAK,CAAE,IAAI,gBAAgB,KAAK,IAAI,KAAK;AAElE,MAAI,OAAO,SAAS;AAClB,WAAO;EACT;AACA,SAAO,gBAAgB,KAAK;AAC9B;",
  "names": ["sha256"]
}
