import {
  ensureBytecodePrefix,
  extractIPFSUri
} from "./chunk-BN2PGHWU.js";
import {
  extractMinimalProxyImplementationAddress,
  resolveImplementation
} from "./chunk-VHZNJSRK.js";
import {
  isZkSyncChain
} from "./chunk-W734EX4N.js";
import {
  signMessage,
  signTypedData,
  signatureToHex
} from "./chunk-M37VZ3HW.js";
import {
  hashMessage
} from "./chunk-NUMAW4ZH.js";
import "./chunk-QQQWUGLR.js";
import {
  isContractDeployed
} from "./chunk-BRUHTZMA.js";
import "./chunk-PH5FAAQQ.js";
import {
  bytesToBigInt,
  bytesToBool,
  bytesToNumber,
  bytesToString,
  fromBytes,
  sha256
} from "./chunk-GPUIP2EQ.js";
import "./chunk-EBXHUO3L.js";
import {
  waitForReceipt
} from "./chunk-OLVV2SZ2.js";
import "./chunk-QWTK625L.js";
import {
  concatHex
} from "./chunk-HIZG7GSI.js";
import {
  sign
} from "./chunk-63PYJADF.js";
import {
  eth_getBalance
} from "./chunk-4SWHQGAJ.js";
import {
  sendTransaction
} from "./chunk-MAIJ6UKZ.js";
import "./chunk-HH2NFLAA.js";
import {
  eth_sendRawTransaction
} from "./chunk-CMXLKATA.js";
import {
  getGasPrice
} from "./chunk-FVFXS5GY.js";
import "./chunk-352E3LEE.js";
import "./chunk-NVBBE2QQ.js";
import "./chunk-6ZAO22CU.js";
import "./chunk-KLXH3ZM6.js";
import "./chunk-XHHJLHAT.js";
import {
  getClaimParams
} from "./chunk-VU5WPLDS.js";
import "./chunk-JJ3ZJ4YV.js";
import "./chunk-RBA2RHPO.js";
import "./chunk-WKGON63R.js";
import {
  randomBytesHex
} from "./chunk-OY6VNEJL.js";
import {
  max,
  min
} from "./chunk-24KQIOR2.js";
import {
  base64ToString,
  uint8ArrayToBase64
} from "./chunk-FNFCYA7D.js";
import "./chunk-YCZ3YGMG.js";
import {
  detectMethod
} from "./chunk-CQDDA5CA.js";
import "./chunk-RTXSFAE7.js";
import "./chunk-AJYCYNAD.js";
import {
  encodeAbiParameters
} from "./chunk-76WCYAWD.js";
import {
  resolvePromisedValue
} from "./chunk-KJYLQJSK.js";
import {
  getContract
} from "./chunk-V4R6W4TB.js";
import {
  serializeSignature
} from "./chunk-Q3JOSKWE.js";
import {
  getRpcClient
} from "./chunk-5PURIJGG.js";
import {
  stringify
} from "./chunk-7IZG4EP5.js";
import {
  checksumAddress,
  getAddress,
  isAddress,
  shortenAddress,
  shortenHex
} from "./chunk-4ZSCZGTN.js";
import {
  keccak256
} from "./chunk-C4YSBPCB.js";
import {
  boolToBytes,
  hexToBytes,
  numberToBytes,
  stringToBytes,
  toBytes
} from "./chunk-PJWFC5K2.js";
import {
  encodePacked,
  getContractAddress,
  isBytes,
  recoverAddress,
  serializeTransaction
} from "./chunk-VIJQ2DKR.js";
import {
  boolToHex,
  fromHex,
  hexToBigInt,
  hexToBool,
  hexToNumber,
  hexToString,
  hexToUint8Array,
  isHex,
  numberToHex,
  padHex,
  stringToHex,
  toHex,
  uint8ArrayToHex
} from "./chunk-HBHEB2SD.js";
import "./chunk-GDDTQ4UI.js";
import {
  fromGwei,
  toEther,
  toTokens,
  toUnits,
  toWei
} from "./chunk-HAADYJEF.js";
import {
  prepareTransaction
} from "./chunk-WAYCTEWF.js";
import "./chunk-MCBKQZV4.js";
import "./chunk-DZWKJ2HW.js";
import {
  maxUint256,
  toFunctionSelector
} from "./chunk-YMTKIPCL.js";
import "./chunk-KMJ22NCU.js";
import "./chunk-ODQ2TGHS.js";
import {
  withCache
} from "./chunk-TQTA6FSB.js";
import {
  setThirdwebDomains
} from "./chunk-CT4S5XSC.js";
import "./chunk-F7BKMWKP.js";
import "./chunk-3OXDSLPJ.js";
import "./chunk-PPP72TBL.js";
import "./chunk-MSFXBLHD.js";

// node_modules/thirdweb/dist/esm/utils/any-evm/is-eip155-enforced.js
var EIP_ENFORCED_CACHE = /* @__PURE__ */ new Map();
async function isEIP155Enforced(options) {
  const chainId = options.chain.id;
  if (EIP_ENFORCED_CACHE.has(chainId)) {
    return EIP_ENFORCED_CACHE.get(chainId);
  }
  let result = false;
  try {
    const rpcRequest = getRpcClient(options);
    await eth_sendRawTransaction(rpcRequest, "0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222");
  } catch (e) {
    const errorMsg = e.toString().toLowerCase();
    const errorJson = JSON.stringify(e).toLowerCase();
    if (matchError(errorMsg) || matchError(errorJson)) {
      result = true;
    }
  }
  EIP_ENFORCED_CACHE.set(chainId, result);
  return result;
}
var ERROR_SUBSTRINGS_COMPOSITE = [
  ["account", "not found"],
  ["wrong", "chainid"]
];
var ERROR_SUBSTRINGS = [
  "eip-155",
  "eip155",
  "protected",
  "invalid chain id for signer",
  "chain id none",
  "chain_id mismatch",
  "recovered sender mismatch",
  "transaction hash mismatch",
  "chainid no support",
  "chainid (0)",
  "chainid(0)",
  "invalid sender"
];
function matchError(error) {
  const hasError = ERROR_SUBSTRINGS.some((substring) => error.includes(substring));
  if (hasError) {
    return true;
  }
  return ERROR_SUBSTRINGS_COMPOSITE.some((arr) => {
    let foundError = true;
    for (const substring of arr) {
      foundError && (foundError = error.includes(substring));
    }
    return foundError;
  });
}

// node_modules/thirdweb/dist/esm/utils/any-evm/keyless-transaction.js
async function getKeylessTransaction(options) {
  const hash = keccak256(serializeTransaction(options.transaction));
  const address = await recoverAddress({
    hash,
    signature: serializeSignature(options.signature)
  });
  const transaction = serializeTransaction(options.transaction, options.signature);
  return {
    signerAddress: address,
    transaction
  };
}

// node_modules/thirdweb/dist/esm/contract/deployment/utils/create-2-factory.js
var COMMON_FACTORY_ADDRESS = "0x4e59b44847b379578588920cA78FbF26c0B4956C";
var CREATE2_FACTORY_BYTECODE = "0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3";
var SIGNATURE = {
  v: 27n,
  r: "0x2222222222222222222222222222222222222222222222222222222222222222",
  s: "0x2222222222222222222222222222222222222222222222222222222222222222"
};
async function computeCreate2FactoryAddress(options) {
  const chainId = options.chain.id;
  return withCache(async () => {
    var _a, _b, _c, _d;
    if (CUSTOM_GAS_FOR_CHAIN[chainId]) {
      const enforceEip1552 = await isEIP155Enforced(options);
      const eipChain2 = enforceEip1552 ? chainId : 0;
      const gasPrice = (_a = CUSTOM_GAS_FOR_CHAIN[chainId.toString()]) == null ? void 0 : _a.gasPrice;
      const gasLimit = (_b = CUSTOM_GAS_FOR_CHAIN[chainId.toString()]) == null ? void 0 : _b.gasLimit;
      const deploymentInfo2 = await _getCreate2FactoryDeploymentInfo(eipChain2, {
        gasPrice,
        gasLimit
      });
      return deploymentInfo2.predictedAddress;
    }
    const allBinsInfo = await Promise.all([
      // to generate EIP-155 transaction
      ...CUSTOM_GAS_BINS.map((b) => {
        return _getCreate2FactoryDeploymentInfo(chainId, { gasPrice: b });
      }),
      // to generate pre EIP-155 transaction, hence chainId 0
      ...CUSTOM_GAS_BINS.map((b) => {
        return _getCreate2FactoryDeploymentInfo(0, { gasPrice: b });
      })
    ]);
    const allFactories = await Promise.all(allBinsInfo.map((b) => {
      const tempFactory = getContract({
        ...options,
        address: b.predictedAddress
      });
      return isContractDeployed(tempFactory);
    }));
    const indexOfCommonFactory = allBinsInfo.findIndex((b) => b.predictedAddress === COMMON_FACTORY_ADDRESS);
    if (indexOfCommonFactory && allFactories[indexOfCommonFactory]) {
      return COMMON_FACTORY_ADDRESS;
    }
    const indexOfExistingDeployment = allFactories.findIndex((b) => b);
    if (indexOfExistingDeployment && allBinsInfo && ((_c = allBinsInfo[indexOfExistingDeployment]) == null ? void 0 : _c.predictedAddress)) {
      return (_d = allBinsInfo[indexOfExistingDeployment]) == null ? void 0 : _d.predictedAddress;
    }
    const [enforceEip155, gasPriceFetched] = await Promise.all([
      isEIP155Enforced(options),
      getGasPrice(options)
    ]);
    const eipChain = enforceEip155 ? chainId : 0;
    const bin = _getNearestGasPriceBin(gasPriceFetched);
    const deploymentInfo = await _getCreate2FactoryDeploymentInfo(eipChain, {
      gasPrice: bin
    });
    return deploymentInfo.predictedAddress;
  }, {
    cacheKey: `create2factory:${chainId}`,
    cacheTime: 24 * 60 * 60 * 1e3
    // 1 day
  });
}
async function getDeployedCreate2Factory(options) {
  const address = await computeCreate2FactoryAddress(options);
  const factory = getContract({
    ...options,
    address
  });
  const isDeployed = await isContractDeployed(factory);
  if (!isDeployed) {
    return null;
  }
  return factory;
}
async function deployCreate2Factory(options) {
  const { client, chain, account } = options;
  const enforceEip155 = await isEIP155Enforced(options);
  const chainId = options.chain.id;
  const eipChain = enforceEip155 ? chainId : 0;
  const rpcRequest = getRpcClient({
    client,
    chain
  });
  const gasPriceFetched = await getGasPrice(options);
  const bin = _getNearestGasPriceBin(gasPriceFetched);
  const deploymentInfo = await _getCreate2FactoryDeploymentInfo(eipChain, {
    gasPrice: bin
  });
  const balance = await eth_getBalance(rpcRequest, {
    address: deploymentInfo.signerAddress
  });
  if (balance < deploymentInfo.valueToSend) {
    const transaction = prepareTransaction({
      chain,
      client,
      to: deploymentInfo.signerAddress,
      value: deploymentInfo.valueToSend
    });
    const res = await sendTransaction({ transaction, account });
    await waitForReceipt(res);
  }
  const transactionHash = await eth_sendRawTransaction(rpcRequest, deploymentInfo.transaction);
  return {
    transactionHash
  };
}
async function _getCreate2FactoryDeploymentInfo(chainId, gasOptions) {
  const gasPrice = gasOptions.gasPrice ? gasOptions.gasPrice : 100n * 10n ** 9n;
  const gas = gasOptions.gasLimit ? gasOptions.gasLimit : 100000n;
  const deploymentTransaction = await getKeylessTransaction({
    transaction: {
      gasPrice,
      gas,
      nonce: 0,
      data: CREATE2_FACTORY_BYTECODE,
      chainId: chainId !== 0 ? Number(chainId) : void 0
    },
    signature: SIGNATURE
  });
  const create2FactoryAddress = getContractAddress({
    from: deploymentTransaction.signerAddress,
    nonce: 0n
  });
  return {
    ...deploymentTransaction,
    valueToSend: gasPrice * gas,
    predictedAddress: create2FactoryAddress
  };
}
function _getNearestGasPriceBin(gasPrice) {
  return CUSTOM_GAS_BINS.find((e) => e >= gasPrice) || gasPrice;
}
var CUSTOM_GAS_FOR_CHAIN = {
  "5001": {
    name: "Mantle Testnet",
    gasPrice: 1n
  },
  "71402": {
    name: "Godwoken Mainnet",
    gasPrice: 40000n * 10n ** 9n
  },
  "1351057110": {
    name: "Chaos (SKALE Testnet)",
    gasPrice: 100000n
  },
  "361": {
    name: "Theta Mainnet",
    gasPrice: 4000n * 10n ** 9n
  },
  "365": {
    name: "Theta Testnet",
    gasPrice: 4000n * 10n ** 9n
  },
  "7700": {
    name: "Canto",
    gasPrice: 1000n * 10n ** 9n
  },
  "7701": {
    name: "Canto Testnet",
    gasPrice: 1000n * 10n ** 9n
  },
  "338": {
    name: "Cronos Testnet",
    gasPrice: 2000n * 10n ** 9n
  },
  "199": {
    name: "BitTorrent Chain",
    gasPrice: 300000n * 10n ** 9n
  },
  "88882": {
    name: "Spicy Chain",
    gasPrice: 2500n * 10n ** 9n,
    gasLimit: 200000n
  },
  "88888": {
    name: "Chiliz Chain",
    gasPrice: 2500n * 10n ** 9n,
    gasLimit: 200000n
  }
};
var CUSTOM_GAS_BINS = [
  1n,
  1n * 10n ** 9n,
  100n * 10n ** 9n,
  500n * 10n ** 9n,
  1000n * 10n ** 9n,
  2500n * 10n ** 9n,
  5000n * 10n ** 9n,
  7500n * 10n ** 9n,
  10000n * 10n ** 9n,
  25000n * 10n ** 9n,
  50000n * 10n ** 9n,
  75000n * 10n ** 9n,
  100000n * 10n ** 9n,
  250000n * 10n ** 9n,
  500000n * 10n ** 9n,
  750000n * 10n ** 9n,
  1000000n * 10n ** 9n
];

// node_modules/thirdweb/dist/esm/utils/any-evm/keccak-id.js
function keccakId(input) {
  return keccak256(stringToBytes(input));
}

// node_modules/thirdweb/dist/esm/utils/any-evm/get-salt-hash.js
function getSaltHash(bytecode) {
  const bytecodeHash = keccakId(ensureBytecodePrefix(bytecode));
  const salt = `tw.${bytecodeHash}`;
  return keccakId(salt);
}

// node_modules/thirdweb/dist/esm/utils/any-evm/compute-deployment-address.js
function computeDeploymentAddress(options) {
  const bytecode = ensureBytecodePrefix(options.bytecode);
  const saltHash = options.salt ? keccakId(options.salt) : getSaltHash(bytecode);
  const initBytecode = encodePacked(["bytes", "bytes"], [bytecode, options.encodedArgs]);
  const deployInfoPacked = encodePacked(["bytes1", "address", "bytes32", "bytes32"], [
    "0xff",
    options.create2FactoryAddress,
    saltHash,
    keccak256(encodePacked(["bytes"], [initBytecode]))
  ]);
  const hashedDeployInfo = keccak256(encodePacked(["bytes"], [deployInfoPacked]));
  return `0x${hashedDeployInfo.slice(26)}`;
}

// node_modules/thirdweb/dist/esm/utils/any-evm/get-init-bytecode-with-salt.js
function getInitBytecodeWithSalt(options) {
  const bytecode = ensureBytecodePrefix(options.bytecode);
  const saltHash = options.salt ? keccakId(options.salt) : getSaltHash(bytecode);
  const encodedArgs = typeof options.encodedArgs === "string" ? options.encodedArgs : uint8ArrayToHex(options.encodedArgs);
  return encodePacked(["bytes32", "bytes", "bytes"], [saltHash, bytecode, encodedArgs]);
}

// node_modules/thirdweb/dist/esm/utils/signatures/resolve-signature.js
var function_cache = /* @__PURE__ */ new Map();
var event_cache = /* @__PURE__ */ new Map();
var SIGNATURE_API = "https://www.4byte.directory/api/v1";
async function resolveFunctionSignature(hexSig) {
  var _a;
  if (function_cache.has(hexSig)) {
    return function_cache.get(hexSig);
  }
  const res = await fetch(`${SIGNATURE_API}/signatures/?format=json&hex_signature=${hexSig}`);
  if (!res.ok) {
    (_a = res.body) == null ? void 0 : _a.cancel();
    return null;
  }
  const data = await res.json();
  if (data.count === 0) {
    return null;
  }
  const signature = `function ${data.results[0].text_signature}`;
  function_cache.set(hexSig, signature);
  return signature;
}
async function resolveEventSignature(hexSig) {
  var _a;
  if (event_cache.has(hexSig)) {
    return event_cache.get(hexSig);
  }
  const res = await fetch(`${SIGNATURE_API}/event-signatures/?format=json&hex_signature=${hexSig}`);
  if (!res.ok) {
    (_a = res.body) == null ? void 0 : _a.cancel();
    return null;
  }
  const data = await res.json();
  if (data.count === 0) {
    return null;
  }
  const signature = `event ${uppercaseFirstLetter(data.results[0].text_signature)}`;
  event_cache.set(hexSig, signature);
  return signature;
}
function uppercaseFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
async function resolveSignature(hexSig) {
  if (hexSig.startsWith("0x")) {
    hexSig = hexSig.slice(2);
  }
  const all = await Promise.all([
    resolveFunctionSignature(hexSig),
    resolveEventSignature(hexSig)
  ]);
  return {
    function: all[0],
    event: all[1]
  };
}
async function resolveSignatures(hexSigs) {
  hexSigs = Array.from(new Set(hexSigs));
  const all = await Promise.all(hexSigs.map((hexSig) => resolveSignature(hexSig)));
  return {
    functions: all.map((x) => x.function).filter((x) => x !== null).sort(),
    events: all.map((x) => x.event).filter((x) => x !== null).sort()
  };
}

// node_modules/thirdweb/dist/esm/utils/jwt/jwt-header.js
var PRECOMPILED_B64_ENCODED_JWT_HEADER = "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9";

// node_modules/thirdweb/dist/esm/utils/jwt/decode-jwt.js
function decodeJWT(jwt) {
  const [encodedHeader, encodedPayload, encodedSignature] = jwt.split(".");
  if (encodedHeader !== PRECOMPILED_B64_ENCODED_JWT_HEADER) {
    throw new Error("Invalid JWT header");
  }
  if (!encodedPayload || !encodedSignature) {
    throw new Error("Invalid JWT");
  }
  const payload = JSON.parse(base64ToString(encodedPayload));
  const signature = base64ToString(encodedSignature);
  return {
    payload,
    signature
  };
}

// node_modules/thirdweb/dist/esm/utils/jwt/encode-jwt.js
async function encodeJWT(options) {
  const payload = await ensureJWTPayload(options.payload);
  const message = JSON.stringify(payload);
  const signature = await options.account.signMessage({ message });
  const encodedData = uint8ArrayToBase64(stringToBytes(JSON.stringify(payload)), { urlSafe: true });
  const encodedSignature = uint8ArrayToBase64(stringToBytes(signature), {
    urlSafe: true
  });
  return `${PRECOMPILED_B64_ENCODED_JWT_HEADER}.${encodedData}.${encodedSignature}`;
}
async function ensureJWTPayload(payload) {
  return {
    iss: payload.iss,
    sub: payload.sub,
    aud: payload.aud,
    exp: Math.floor(payload.exp.getTime() / 1e3),
    nbf: Math.floor(payload.nbf.getTime() / 1e3),
    iat: Math.floor(payload.iat.getTime() / 1e3),
    // default to uuid if jti is not provided
    jti: payload.jti || await randomBytesHex(),
    ctx: payload.ctx
  };
}

// node_modules/thirdweb/dist/esm/utils/jwt/refresh-jwt.js
var DEFAULT_EXPIRATION_TIME = 60 * 60 * 24;
async function refreshJWT(options) {
  const { account, jwt, expirationTime = DEFAULT_EXPIRATION_TIME } = options;
  const payload = decodeJWT(jwt).payload;
  return encodeJWT({
    payload: {
      iss: payload.iss,
      sub: payload.sub,
      aud: payload.aud,
      nbf: /* @__PURE__ */ new Date(),
      exp: new Date(Date.now() + expirationTime),
      iat: /* @__PURE__ */ new Date(),
      ctx: payload.ctx
    },
    account
  });
}

// node_modules/thirdweb/dist/esm/utils/contract/parse-abi-params.js
function parseAbiParams(constructorParamTypes, constructorParamValues) {
  if (constructorParamTypes.length !== constructorParamValues.length) {
    throw new Error(`Passed the wrong number of constructor arguments: ${constructorParamValues.length}, expected ${constructorParamTypes.length}`);
  }
  return constructorParamTypes.map((type, index) => {
    const value = constructorParamValues[index];
    if (type === "tuple" || type.endsWith("[]")) {
      if (typeof value === "string") {
        return JSON.parse(value);
      }
      return value;
    }
    if (type === "string") {
      return String(value);
    }
    if (type === "bytes32") {
      if (!isHex(value)) {
        throw new Error(`${value} is not a valid hex string`);
      }
      return padHex(value);
    }
    if (type.startsWith("bytes")) {
      if (!isHex(value)) {
        throw new Error(`${value} is not a valid hex string`);
      }
      return value;
    }
    if (type === "address") {
      if (typeof value !== "string" || !isAddress(value)) {
        throw new Error(`${value} is not a valid address`);
      }
      return value;
    }
    if (type.startsWith("uint") || type.startsWith("int")) {
      if (typeof value === "bigint") {
        return value;
      }
      if (typeof value !== "string" && typeof value !== "number") {
        throw new Error(`Cannot convert type ${typeof value} to BigInt`);
      }
      try {
        const val = BigInt(value);
        return val;
      } catch (err) {
        throw new Error(err.message);
      }
    }
    if (type.startsWith("bool")) {
      if (value === "false" || value === false) {
        return false;
      }
      if (value === "true" || value === true) {
        return true;
      }
      throw new Error("Invalid boolean value. Expecting either 'true' or 'false'");
    }
    return value;
  });
}
export {
  boolToBytes,
  boolToHex,
  bytesToBigInt,
  bytesToBool,
  bytesToNumber,
  bytesToString,
  checksumAddress,
  computeCreate2FactoryAddress,
  computeDeploymentAddress,
  concatHex,
  decodeJWT,
  deployCreate2Factory,
  detectMethod,
  encodeAbiParameters,
  encodeJWT,
  encodePacked,
  ensureBytecodePrefix,
  extractIPFSUri,
  extractMinimalProxyImplementationAddress,
  fromBytes,
  fromGwei,
  fromHex,
  getAddress,
  getClaimParams,
  getDeployedCreate2Factory,
  getInitBytecodeWithSalt,
  getKeylessTransaction,
  getSaltHash,
  hashMessage,
  hexToBigInt,
  hexToBool,
  hexToBytes,
  hexToNumber,
  hexToString,
  hexToUint8Array,
  isAddress,
  isBytes,
  isContractDeployed,
  isEIP155Enforced,
  isHex,
  isZkSyncChain,
  keccak256,
  keccakId,
  max,
  maxUint256,
  min,
  numberToBytes,
  numberToHex,
  padHex,
  parseAbiParams,
  refreshJWT,
  resolveImplementation,
  resolvePromisedValue,
  resolveSignature,
  resolveSignatures,
  setThirdwebDomains,
  sha256,
  shortenAddress,
  shortenHex,
  sign,
  signMessage,
  signTypedData,
  signatureToHex,
  stringToBytes,
  stringToHex,
  stringify,
  toBytes,
  toEther,
  toFunctionSelector,
  toHex,
  toTokens,
  toUnits,
  toWei,
  uint8ArrayToHex
};
//# sourceMappingURL=thirdweb_utils.js.map
