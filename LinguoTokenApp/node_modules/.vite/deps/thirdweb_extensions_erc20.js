import {
  MerkleTree,
  hashEntry
} from "./chunk-67IDY2FH.js";
import {
  claimTo,
  isClaimToSupported
} from "./chunk-VLQHL4JA.js";
import {
  convertErc20Amount
} from "./chunk-MYHU6A7S.js";
import {
  isSetContractURISupported
} from "./chunk-2NDVN342.js";
import {
  getApprovalForTransaction
} from "./chunk-QFA4PPNH.js";
import {
  getActiveClaimCondition,
  getActiveClaimConditionId,
  getClaimConditionById,
  isGetActiveClaimConditionIdSupported,
  isGetActiveClaimConditionSupported,
  isGetClaimConditionByIdSupported
} from "./chunk-YDOZLQDI.js";
import {
  balanceOf,
  getBalance,
  isBalanceOfSupported
} from "./chunk-S3CQ7WPN.js";
import {
  upload
} from "./chunk-RLNZWMRM.js";
import {
  encodeTransfer,
  isTransferSupported,
  transfer
} from "./chunk-IIXAVZJG.js";
import {
  getCurrencyMetadata
} from "./chunk-G2E676OV.js";
import {
  allowance,
  isAllowanceSupported
} from "./chunk-LVQC2JOT.js";
import {
  decimals
} from "./chunk-3IAHUVMH.js";
import {
  isDecimalsSupported
} from "./chunk-QEOPQ57A.js";
import "./chunk-VU5WPLDS.js";
import {
  isContractURISupported
} from "./chunk-JJ3ZJ4YV.js";
import "./chunk-RBA2RHPO.js";
import {
  isNameSupported,
  isSymbolSupported,
  name
} from "./chunk-WKGON63R.js";
import {
  randomBytesHex
} from "./chunk-OY6VNEJL.js";
import {
  toBigInt
} from "./chunk-24KQIOR2.js";
import "./chunk-FNFCYA7D.js";
import {
  prepareEvent
} from "./chunk-ZVEVVD2S.js";
import {
  approve
} from "./chunk-Z7P3VMHU.js";
import {
  isApproveSupported
} from "./chunk-PQAHGQ5E.js";
import {
  once,
  prepareContractCall
} from "./chunk-FSNTYITZ.js";
import "./chunk-WWY7S4YD.js";
import {
  NATIVE_TOKEN_ADDRESS,
  isNativeTokenAddress
} from "./chunk-YCZ3YGMG.js";
import {
  detectMethod
} from "./chunk-CQDDA5CA.js";
import {
  readContract
} from "./chunk-RTXSFAE7.js";
import "./chunk-AJYCYNAD.js";
import "./chunk-76WCYAWD.js";
import "./chunk-KJYLQJSK.js";
import "./chunk-V4R6W4TB.js";
import "./chunk-Q3JOSKWE.js";
import "./chunk-5PURIJGG.js";
import "./chunk-7IZG4EP5.js";
import "./chunk-4ZSCZGTN.js";
import "./chunk-C4YSBPCB.js";
import "./chunk-PJWFC5K2.js";
import "./chunk-VIJQ2DKR.js";
import {
  isHex,
  stringToHex,
  toHex
} from "./chunk-HBHEB2SD.js";
import "./chunk-GDDTQ4UI.js";
import {
  toUnits,
  toWei
} from "./chunk-HAADYJEF.js";
import "./chunk-WAYCTEWF.js";
import "./chunk-MCBKQZV4.js";
import "./chunk-DZWKJ2HW.js";
import {
  maxUint256
} from "./chunk-YMTKIPCL.js";
import "./chunk-KMJ22NCU.js";
import "./chunk-ODQ2TGHS.js";
import "./chunk-TQTA6FSB.js";
import "./chunk-CT4S5XSC.js";
import "./chunk-F7BKMWKP.js";
import "./chunk-3OXDSLPJ.js";
import "./chunk-PPP72TBL.js";
import "./chunk-MSFXBLHD.js";

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IERC20/read/totalSupply.js
var FN_SELECTOR = "0x18160ddd";
var FN_INPUTS = [];
var FN_OUTPUTS = [
  {
    type: "uint256"
  }
];
function isTotalSupplySupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS]
  });
}
async function totalSupply(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
    params: []
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IERC20/write/transferFrom.js
var FN_SELECTOR2 = "0x23b872dd";
var FN_INPUTS2 = [
  {
    type: "address",
    name: "from"
  },
  {
    type: "address",
    name: "to"
  },
  {
    type: "uint256",
    name: "value"
  }
];
var FN_OUTPUTS2 = [
  {
    type: "bool"
  }
];
function isTransferFromSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR2, FN_INPUTS2, FN_OUTPUTS2]
  });
}
function transferFrom(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR2, FN_INPUTS2, FN_OUTPUTS2],
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [
        resolvedOptions.from,
        resolvedOptions.to,
        resolvedOptions.value
      ];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    },
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/read/isERC20.js
function isERC20(availableSelectors) {
  return [
    isNameSupported(availableSelectors),
    isSymbolSupported(availableSelectors),
    isDecimalsSupported(availableSelectors),
    isTotalSupplySupported(availableSelectors),
    isBalanceOfSupported(availableSelectors),
    isTransferSupported(availableSelectors),
    isTransferFromSupported(availableSelectors),
    isApproveSupported(availableSelectors),
    isAllowanceSupported(availableSelectors)
  ].every(Boolean);
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IVotes/read/delegates.js
var FN_SELECTOR3 = "0x587cde1e";
var FN_INPUTS3 = [
  {
    type: "address",
    name: "account"
  }
];
var FN_OUTPUTS3 = [
  {
    type: "address"
  }
];
async function delegates(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR3, FN_INPUTS3, FN_OUTPUTS3],
    params: [options.account]
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IMintableERC20/write/mintTo.js
var FN_SELECTOR4 = "0x449a52f8";
var FN_INPUTS4 = [
  {
    type: "address",
    name: "to"
  },
  {
    type: "uint256",
    name: "amount"
  }
];
var FN_OUTPUTS4 = [];
function isMintToSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR4, FN_INPUTS4, FN_OUTPUTS4]
  });
}
function mintTo(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR4, FN_INPUTS4, FN_OUTPUTS4],
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.to, resolvedOptions.amount];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    },
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/write/mintTo.js
function mintTo2(options) {
  return mintTo({
    contract: options.contract,
    asyncParams: async () => {
      let amount;
      if ("amount" in options) {
        const { decimals: decimals2 } = await import("./decimals-VRBK5JZJ.js");
        const d = await decimals2(options).catch(() => 18);
        amount = toUnits(options.amount.toString(), d);
      } else {
        amount = options.amountWei;
      }
      return {
        to: options.to,
        amount,
        overrides: options.overrides
      };
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/write/transferFrom.js
function transferFrom2(options) {
  return transferFrom({
    contract: options.contract,
    asyncParams: async () => {
      let amount;
      if ("amount" in options) {
        const { decimals: decimals2 } = await import("./decimals-VRBK5JZJ.js");
        const d = await decimals2(options).catch(() => 18);
        amount = toUnits(options.amount.toString(), d);
      } else {
        amount = options.amountWei;
      }
      return {
        from: options.from,
        to: options.to,
        value: amount,
        overrides: {
          erc20Value: {
            amountWei: amount,
            tokenAddress: options.contract.address
          },
          ...options.overrides
        }
      };
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/common/__generated__/IMulticall/write/multicall.js
var FN_SELECTOR5 = "0xac9650d8";
var FN_INPUTS5 = [
  {
    type: "bytes[]",
    name: "data"
  }
];
var FN_OUTPUTS5 = [
  {
    type: "bytes[]",
    name: "results"
  }
];
function isMulticallSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR5, FN_INPUTS5, FN_OUTPUTS5]
  });
}
function multicall(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR5, FN_INPUTS5, FN_OUTPUTS5],
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.data];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    },
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/write/transferBatch.js
function transferBatch(options) {
  return multicall({
    contract: options.contract,
    asyncParams: async () => {
      return {
        data: await Promise.all(options.batch.map(async (transfer2) => {
          let amount;
          if ("amount" in transfer2) {
            const { decimals: decimals2 } = await import("./decimals-VRBK5JZJ.js");
            const d = await decimals2(options).catch(() => 18);
            amount = toUnits(transfer2.amount.toString(), d);
          } else {
            amount = transfer2.amountWei;
          }
          return encodeTransfer({
            to: transfer2.to,
            value: amount,
            overrides: {
              erc20Value: {
                amountWei: amount,
                tokenAddress: options.contract.address
              }
            }
          });
        }))
      };
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IBurnableERC20/write/burn.js
var FN_SELECTOR6 = "0x42966c68";
var FN_INPUTS6 = [
  {
    type: "uint256",
    name: "amount"
  }
];
var FN_OUTPUTS6 = [];
function burn(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR6, FN_INPUTS6, FN_OUTPUTS6],
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.amount];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    },
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IBurnableERC20/write/burnFrom.js
var FN_SELECTOR7 = "0x79cc6790";
var FN_INPUTS7 = [
  {
    type: "address",
    name: "account"
  },
  {
    type: "uint256",
    name: "amount"
  }
];
var FN_OUTPUTS7 = [];
function burnFrom(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR7, FN_INPUTS7, FN_OUTPUTS7],
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.account, resolvedOptions.amount];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    },
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IDropERC20/read/claimCondition.js
var FN_SELECTOR8 = "0xd637ed59";
var FN_INPUTS8 = [];
var FN_OUTPUTS8 = [
  {
    type: "uint256",
    name: "currentStartId"
  },
  {
    type: "uint256",
    name: "count"
  }
];
function isClaimConditionSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR8, FN_INPUTS8, FN_OUTPUTS8]
  });
}
async function claimCondition(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR8, FN_INPUTS8, FN_OUTPUTS8],
    params: []
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/drops/read/getClaimConditions.js
async function getClaimConditions(options) {
  try {
    const [startId, count] = await claimCondition(options);
    const conditionPromises = [];
    for (let i = startId; i < startId + count; i++) {
      conditionPromises.push(getClaimConditionById({
        ...options,
        conditionId: i
      }));
    }
    return Promise.all(conditionPromises);
  } catch {
    throw new Error("Claim condition not found");
  }
}
function isGetClaimConditionsSupported(availableSelectors) {
  return isClaimConditionSupported(availableSelectors) && isGetClaimConditionByIdSupported(availableSelectors);
}

// node_modules/thirdweb/dist/esm/utils/date.js
function tenYearsFromNow() {
  return new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10);
}
function dateToSeconds(date) {
  return toBigInt(Math.floor(date.getTime() / 1e3));
}

// node_modules/thirdweb/dist/esm/utils/extensions/drops/process-override-list.js
async function processOverrideList(options) {
  const hashEntryFn = options.hashEntry || hashEntry;
  const shardNybbles = options.shardNybbles || 2;
  const shards = {};
  for (const snapshotEntry of options.overrides) {
    const shard = snapshotEntry.address.slice(2, 2 + shardNybbles).toLowerCase();
    if (shards[shard] === void 0) {
      shards[shard] = [];
    }
    shards[shard].push(snapshotEntry);
  }
  const subTrees = await Promise.all(Object.entries(shards).map(async ([shard, entries]) => [
    shard,
    new MerkleTree(await Promise.all(entries.map(async (entry) => {
      return hashEntryFn({
        entry,
        chain: options.chain,
        client: options.client,
        tokenDecimals: options.tokenDecimals
      });
    }))).getHexRoot()
  ]));
  const roots = Object.fromEntries(subTrees);
  const tree = new MerkleTree(Object.values(roots));
  const shardsToUpload = [];
  for (const [shardId, entries] of Object.entries(shards)) {
    const data = {
      // biome-ignore lint/style/noNonNullAssertion: we know this is in bounds
      proofs: tree.getHexProof(roots[shardId]),
      entries
    };
    shardsToUpload.push({
      data: JSON.stringify(data),
      name: `${shardId}.json`
    });
  }
  let uris = await upload({
    client: options.client,
    files: shardsToUpload
  });
  if (!Array.isArray(uris)) {
    uris = [uris];
  }
  if (uris.length === 0) {
    throw new Error("No URIs returned from uploading merkle tree shards");
  }
  const baseUri = uris[0].slice(0, uris[0].lastIndexOf("/"));
  const originalEntriesUri = await upload({
    client: options.client,
    files: [JSON.stringify(options.overrides)]
  });
  const shardedMerkleInfo = {
    merkleRoot: tree.getHexRoot(),
    baseUri,
    originalEntriesUri,
    shardNybbles,
    tokenDecimals: options.tokenDecimals,
    isShardedMerkleTree: true
  };
  const finalUri = await upload({
    client: options.client,
    files: [shardedMerkleInfo]
  });
  return {
    shardedMerkleInfo,
    uri: finalUri
  };
}

// node_modules/thirdweb/dist/esm/utils/extensions/drops/get-multicall-set-claim-claim-conditon-transactions.js
async function getMulticallSetClaimConditionTransactions(options) {
  const merkleInfos = {};
  const phases = await Promise.all(options.phases.map(async (phase) => {
    var _a;
    let merkleRoot = phase.merkleRootHash || toHex("", { size: 32 });
    if (phase.overrideList) {
      const { shardedMerkleInfo, uri } = await processOverrideList({
        overrides: phase.overrideList,
        client: options.contract.client,
        chain: options.contract.chain,
        tokenDecimals: options.tokenDecimals
      });
      merkleInfos[shardedMerkleInfo.merkleRoot] = uri;
      merkleRoot = shardedMerkleInfo.merkleRoot;
    }
    let metadata = "";
    if (phase.metadata && typeof phase.metadata === "string") {
      metadata = phase.metadata;
    } else if (phase.metadata && typeof phase.metadata === "object") {
      metadata = await upload({
        client: options.contract.client,
        files: [phase.metadata]
      });
    }
    return {
      startTimestamp: dateToSeconds(phase.startTime ?? /* @__PURE__ */ new Date(0)),
      currency: phase.currencyAddress || NATIVE_TOKEN_ADDRESS,
      pricePerToken: await convertErc20Amount({
        chain: options.contract.chain,
        client: options.contract.client,
        erc20Address: phase.currencyAddress || NATIVE_TOKEN_ADDRESS,
        amount: ((_a = phase.price) == null ? void 0 : _a.toString()) ?? "0"
      }),
      maxClaimableSupply: phase.maxClaimableSupply ?? maxUint256,
      quantityLimitPerWallet: phase.maxClaimablePerWallet ?? maxUint256,
      merkleRoot,
      metadata,
      supplyClaimed: 0n
    };
  }));
  const encodedTransactions = [];
  if (Object.keys(merkleInfos).length > 0) {
    const [{ getContractMetadata }, { encodeSetContractURI }] = await Promise.all([
      import("./getContractMetadata-KEUKBO7Z.js"),
      import("./setContractURI-LRR7IHUO.js")
    ]);
    const metadata = await getContractMetadata({
      contract: options.contract
    });
    for (const key of Object.keys(metadata.merkle || {})) {
      merkleInfos[key] = metadata.merkle[key];
    }
    const mergedMetadata = {
      ...metadata,
      merkle: merkleInfos
    };
    const uri = await upload({
      client: options.contract.client,
      files: [mergedMetadata]
    });
    const encodedSetContractURI = encodeSetContractURI({
      uri
    });
    encodedTransactions.push(encodedSetContractURI);
  }
  const sortedPhases = phases.sort((a, b) => Number(a.startTimestamp - b.startTimestamp));
  let encodedSetClaimConditions;
  if (options.tokenId !== void 0) {
    const { encodeSetClaimConditions } = await import("./setClaimConditions-4W7UNQT3.js");
    encodedSetClaimConditions = encodeSetClaimConditions({
      tokenId: options.tokenId,
      phases: sortedPhases,
      resetClaimEligibility: options.resetClaimEligibility || false
    });
  } else {
    const { encodeSetClaimConditions } = await import("./setClaimConditions-75HRGROI.js");
    encodedSetClaimConditions = encodeSetClaimConditions({
      phases: sortedPhases,
      resetClaimEligibility: options.resetClaimEligibility || false
    });
  }
  encodedTransactions.push(encodedSetClaimConditions);
  return encodedTransactions;
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IDropERC20/write/setClaimConditions.js
var FN_SELECTOR9 = "0x74bc7db7";
var FN_INPUTS9 = [
  {
    type: "tuple[]",
    name: "phases",
    components: [
      {
        type: "uint256",
        name: "startTimestamp"
      },
      {
        type: "uint256",
        name: "maxClaimableSupply"
      },
      {
        type: "uint256",
        name: "supplyClaimed"
      },
      {
        type: "uint256",
        name: "quantityLimitPerWallet"
      },
      {
        type: "bytes32",
        name: "merkleRoot"
      },
      {
        type: "uint256",
        name: "pricePerToken"
      },
      {
        type: "address",
        name: "currency"
      },
      {
        type: "string",
        name: "metadata"
      }
    ]
  },
  {
    type: "bool",
    name: "resetClaimEligibility"
  }
];
var FN_OUTPUTS9 = [];
function isSetClaimConditionsSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR9, FN_INPUTS9, FN_OUTPUTS9]
  });
}
function setClaimConditions(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR9, FN_INPUTS9, FN_OUTPUTS9],
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [
        resolvedOptions.phases,
        resolvedOptions.resetClaimEligibility
      ];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    },
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/drops/write/setClaimConditions.js
function setClaimConditions2(options) {
  return multicall({
    contract: options.contract,
    asyncParams: async () => {
      return {
        data: await getMulticallSetClaimConditionTransactions({
          contract: options.contract,
          phases: options.phases,
          resetClaimEligibility: options.resetClaimEligibility,
          tokenDecimals: await decimals({ contract: options.contract })
        })
      };
    }
  });
}
function isSetClaimConditionsSupported2(availableSelectors) {
  return isMulticallSupported(availableSelectors) && // needed for setting contract metadata
  isContractURISupported(availableSelectors) && isSetContractURISupported(availableSelectors) && // needed for decimals
  isDecimalsSupported(availableSelectors) && // needs to actually be able to set the claim Conditions
  isSetClaimConditionsSupported(availableSelectors);
}

// node_modules/thirdweb/dist/esm/extensions/erc20/drops/write/resetClaimEligibility.js
function resetClaimEligibility(options) {
  return setClaimConditions({
    contract: options.contract,
    asyncParams: async () => {
      const existingConditions = await getClaimConditions(options);
      return {
        // type is necessary because of viem hex shenanigans (strict vs non-strict `0x` prefix string)
        phases: existingConditions,
        resetClaimEligibility: true
      };
    }
  });
}
function isResetClaimEligibilitySupported(availableSelectors) {
  return isGetClaimConditionsSupported(availableSelectors) && isSetClaimConditionsSupported(availableSelectors);
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/ISignatureMintERC20/write/mintWithSignature.js
var FN_SELECTOR10 = "0x8f0fefbb";
var FN_INPUTS10 = [
  {
    type: "tuple",
    name: "payload",
    components: [
      {
        type: "address",
        name: "to"
      },
      {
        type: "address",
        name: "primarySaleRecipient"
      },
      {
        type: "uint256",
        name: "quantity"
      },
      {
        type: "uint256",
        name: "price"
      },
      {
        type: "address",
        name: "currency"
      },
      {
        type: "uint128",
        name: "validityStartTimestamp"
      },
      {
        type: "uint128",
        name: "validityEndTimestamp"
      },
      {
        type: "bytes32",
        name: "uid"
      }
    ]
  },
  {
    type: "bytes",
    name: "signature"
  }
];
var FN_OUTPUTS10 = [];
function mintWithSignature(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR10, FN_INPUTS10, FN_OUTPUTS10],
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.payload, resolvedOptions.signature];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    },
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/write/sigMint.js
function mintWithSignature2(options) {
  const value = isNativeTokenAddress(options.payload.currency) ? options.payload.price : 0n;
  const erc20Value = !isNativeTokenAddress(options.payload.currency) && options.payload.price > 0n ? {
    amountWei: options.payload.price,
    tokenAddress: options.payload.currency
  } : void 0;
  return mintWithSignature({
    ...options,
    overrides: {
      value,
      erc20Value
    }
  });
}
async function generateMintSignature(options) {
  const { mintRequest, account, contract } = options;
  const currency = mintRequest.currency || NATIVE_TOKEN_ADDRESS;
  const [price, quantity, uid, tokenName] = await Promise.all([
    // price per token in wei
    (async () => {
      if ("priceInWei" in mintRequest && mintRequest.priceInWei) {
        return mintRequest.priceInWei;
      }
      if ("price" in mintRequest && mintRequest.price) {
        const { convertErc20Amount: convertErc20Amount2 } = await import("./convert-erc20-amount-OVRZPATT.js");
        return await convertErc20Amount2({
          amount: mintRequest.price,
          client: contract.client,
          chain: contract.chain,
          erc20Address: currency
        });
      }
      return 0n;
    })(),
    // quantity in wei
    (async () => {
      if ("quantityWei" in mintRequest) {
        return mintRequest.quantityWei;
      }
      const { convertErc20Amount: convertErc20Amount2 } = await import("./convert-erc20-amount-OVRZPATT.js");
      return await convertErc20Amount2({
        amount: mintRequest.quantity,
        client: contract.client,
        chain: contract.chain,
        erc20Address: contract.address
      });
    })(),
    (() => {
      if (mintRequest.uid) {
        return isHex(mintRequest.uid) ? mintRequest.uid : stringToHex(mintRequest.uid, { size: 32 });
      }
      return randomBytesHex();
    })(),
    // ERC20Permit (EIP-712) spec differs from signature mint 721, 1155.
    // it uses the token name in the domain separator
    name({
      contract
    })
  ]);
  const startTime = mintRequest.validityStartTimestamp || /* @__PURE__ */ new Date(0);
  const endTime = mintRequest.validityEndTimestamp || tenYearsFromNow();
  const payload = {
    price,
    quantity,
    uid,
    currency,
    to: mintRequest.to,
    primarySaleRecipient: mintRequest.primarySaleRecipient || account.address,
    validityStartTimestamp: dateToSeconds(startTime),
    validityEndTimestamp: dateToSeconds(endTime)
  };
  const signature = await account.signTypedData({
    domain: {
      name: tokenName,
      version: "1",
      chainId: contract.chain.id,
      verifyingContract: contract.address
    },
    types: { MintRequest: MintRequest20 },
    primaryType: "MintRequest",
    message: payload
  });
  return { payload, signature };
}
var MintRequest20 = [
  { name: "to", type: "address" },
  { name: "primarySaleRecipient", type: "address" },
  { name: "quantity", type: "uint256" },
  { name: "price", type: "uint256" },
  { name: "currency", type: "address" },
  { name: "validityStartTimestamp", type: "uint128" },
  { name: "validityEndTimestamp", type: "uint128" },
  { name: "uid", type: "bytes32" }
];

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IWETH/write/deposit.js
var FN_SELECTOR11 = "0xd0e30db0";

// node_modules/thirdweb/dist/esm/extensions/erc20/write/deposit.js
function deposit(options) {
  const value = "amountWei" in options ? options.amountWei : toWei(options.amount);
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR11, [], []],
    value,
    erc20Value: {
      amountWei: value,
      tokenAddress: options.contract.address
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IWETH/write/withdraw.js
var FN_SELECTOR12 = "0x2e1a7d4d";
var FN_INPUTS11 = [
  {
    type: "uint256",
    name: "amount"
  }
];
var FN_OUTPUTS11 = [];
function withdraw(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR12, FN_INPUTS11, FN_OUTPUTS11],
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.amount];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    },
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IERC20/events/Transfer.js
function transferEvent(filters = {}) {
  return prepareEvent({
    signature: "event Transfer(address indexed from, address indexed to, uint256 value)",
    filters
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IERC20/events/Approval.js
function approvalEvent(filters = {}) {
  return prepareEvent({
    signature: "event Approval(address indexed owner, address indexed spender, uint256 value)",
    filters
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IMintableERC20/events/TokensMinted.js
function tokensMintedEvent(filters = {}) {
  return prepareEvent({
    signature: "event TokensMinted(address indexed mintedTo, uint256 quantityMinted)",
    filters
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IDropERC20/events/TokensClaimed.js
function tokensClaimedEvent(filters = {}) {
  return prepareEvent({
    signature: "event TokensClaimed(uint256 indexed claimConditionIndex, address indexed claimer, address indexed receiver, uint256 quantityClaimed)",
    filters
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IDropERC20/events/ClaimConditionsUpdated.js
function claimConditionsUpdatedEvent() {
  return prepareEvent({
    signature: "event ClaimConditionsUpdated((uint256 startTimestamp, uint256 maxClaimableSupply, uint256 supplyClaimed, uint256 quantityLimitPerWallet, bytes32 merkleRoot, uint256 pricePerToken, address currency, string metadata)[] claimConditions, bool resetEligibility)"
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/ISignatureMintERC20/events/TokensMintedWithSignature.js
function tokensMintedWithSignatureEvent(filters = {}) {
  return prepareEvent({
    signature: "event TokensMintedWithSignature(address indexed signer, address indexed mintedTo, (address to, address primarySaleRecipient, uint256 quantity, uint256 price, address currency, uint128 validityStartTimestamp, uint128 validityEndTimestamp, bytes32 uid) mintRequest)",
    filters
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IVotes/write/delegate.js
var FN_SELECTOR13 = "0x5c19a95c";
var FN_INPUTS12 = [
  {
    type: "address",
    name: "delegatee"
  }
];
var FN_OUTPUTS12 = [];
function delegate(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR13, FN_INPUTS12, FN_OUTPUTS12],
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.delegatee];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    },
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    }
  });
}
export {
  allowance,
  approvalEvent,
  approve,
  balanceOf,
  burn,
  burnFrom,
  claimConditionsUpdatedEvent,
  claimTo,
  decimals,
  delegate,
  delegates,
  deposit,
  generateMintSignature,
  getActiveClaimCondition,
  getActiveClaimConditionId,
  getApprovalForTransaction,
  getBalance,
  getClaimConditionById,
  getClaimConditions,
  getCurrencyMetadata,
  isClaimToSupported,
  isERC20,
  isGetActiveClaimConditionIdSupported,
  isGetActiveClaimConditionSupported,
  isGetClaimConditionByIdSupported,
  isGetClaimConditionsSupported,
  isMintToSupported,
  isResetClaimEligibilitySupported,
  isSetClaimConditionsSupported2 as isSetClaimConditionsSupported,
  mintTo2 as mintTo,
  mintWithSignature2 as mintWithSignature,
  resetClaimEligibility,
  setClaimConditions2 as setClaimConditions,
  tokensClaimedEvent,
  tokensMintedEvent,
  tokensMintedWithSignatureEvent,
  totalSupply,
  transfer,
  transferBatch,
  transferEvent,
  transferFrom2 as transferFrom,
  withdraw
};
//# sourceMappingURL=thirdweb_extensions_erc20.js.map
