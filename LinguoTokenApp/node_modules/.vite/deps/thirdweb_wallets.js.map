{
  "version": 3,
  "sources": ["../../thirdweb/src/wallets/private-key.ts", "../../thirdweb/src/wallets/utils/generateAccount.ts", "../../thirdweb/src/wallets/getAllWalletsList.ts", "../../thirdweb/src/adapters/wallet-adapter.ts"],
  "sourcesContent": ["import { secp256k1 } from \"@noble/curves/secp256k1\";\nimport type {\n  SignableMessage,\n  TransactionSerializable,\n  TypedData,\n  TypedDataDefinition,\n} from \"viem\";\nimport { publicKeyToAddress } from \"viem/utils\";\nimport { getCachedChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { eth_sendRawTransaction } from \"../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { signTransaction } from \"../transaction/actions/sign-transaction.js\";\nimport { type Hex, toHex } from \"../utils/encoding/hex.js\";\nimport { signMessage } from \"../utils/signatures/sign-message.js\";\nimport { signTypedData } from \"../utils/signatures/sign-typed-data.js\";\nimport type { Account } from \"./interfaces/wallet.js\";\n\nexport type PrivateKeyToAccountOptions = {\n  /**\n   * A client is the entry point to the thirdweb SDK.\n   * It is required for all other actions.\n   * You can create a client using the `createThirdwebClient` function. Refer to the [Creating a Client](https://portal.thirdweb.com/typescript/v5/client) documentation for more information.\n   *\n   * You must provide a `clientId` or `secretKey` in order to initialize a client. Pass `clientId` if you want for client-side usage and `secretKey` for server-side usage.\n   *\n   * ```tsx\n   * import { createThirdwebClient } from \"thirdweb\";\n   *\n   * const client = createThirdwebClient({\n   *  clientId: \"<your_client_id>\",\n   * })\n   * ```\n   */\n  client: ThirdwebClient;\n\n  /**\n   * The private key to use for the account.\n   *\n   * Do not commit private key in your code and use environment variables or other secure methods to store the private key.\n   * @example\n   * ```ts\n   * const privateKey = process.env.PRIVATE_KEY;\n   * ```\n   */\n  privateKey: string;\n};\n\n/**\n * Get an `Account` object from a private key.\n * @param options - The options for `privateKeyToAccount`\n * Refer to the type [`PrivateKeyToAccountOptions`](https://portal.thirdweb.com/references/typescript/v5/PrivateKeyToAccountOptions)\n * @returns The `Account` object that represents the private key\n * @example\n * ```ts\n * import { privateKeyToAccount } from \"thirdweb/wallets\"\n *\n * const wallet = privateKeyToAccount({\n *  client,\n *  privateKey: \"...\",\n * });\n * ```\n * @wallet\n */\nexport function privateKeyToAccount(\n  options: PrivateKeyToAccountOptions,\n): Account {\n  const { client } = options;\n  const privateKey = `0x${options.privateKey.replace(/^0x/, \"\")}` satisfies Hex;\n\n  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false));\n  const address = publicKeyToAddress(publicKey); // TODO: Implement publicKeyToAddress natively (will need checksumAddress downstream)\n\n  const account = {\n    address,\n    sendTransaction: async (\n      // TODO: figure out how we would pass our \"chain\" object in here?\n      // maybe we *do* actually have to take in a tx object instead of the raw tx?\n      tx: TransactionSerializable & { chainId: number },\n    ) => {\n      const rpcRequest = getRpcClient({\n        client: client,\n        chain: getCachedChain(tx.chainId),\n      });\n      const signedTx = signTransaction({\n        transaction: tx,\n        privateKey,\n      });\n      const transactionHash = await eth_sendRawTransaction(\n        rpcRequest,\n        signedTx,\n      );\n      return {\n        transactionHash,\n      };\n    },\n    signMessage: async ({ message }: { message: SignableMessage }) => {\n      return signMessage({\n        message,\n        privateKey,\n      });\n    },\n    signTypedData: async <\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(\n      _typedData: TypedDataDefinition<typedData, primaryType>,\n    ) => {\n      return signTypedData({\n        ..._typedData,\n        privateKey,\n      });\n    },\n    signTransaction: async (tx: TransactionSerializable) => {\n      return signTransaction({\n        transaction: tx,\n        privateKey,\n      });\n    },\n  };\n\n  return account satisfies Account;\n}\n", "import { secp256k1 } from \"@noble/curves/secp256k1\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { toHex } from \"../../utils/encoding/hex.js\";\nimport type { Account } from \"../interfaces/wallet.js\";\nimport { privateKeyToAccount } from \"../private-key.js\";\n\nexport type GenerateAccountOptions = {\n  client: ThirdwebClient;\n};\n\n/**\n * Generates a new account with a random private key.\n * @param options - The options for generating the account.\n * @param options.client - The Thirdweb client to use for the generated account.\n * @returns A Thirdweb account.\n * @example\n * ```ts\n * import { generateAccount } from \"thirdweb/wallets\";\n * const account = await generateAccount({ client });\n * ```\n * @walletUtils\n */\nexport async function generateAccount(\n  options: GenerateAccountOptions,\n): Promise<Account> {\n  const privateKey = toHex(secp256k1.utils.randomPrivateKey());\n  return privateKeyToAccount({ privateKey, client: options.client });\n}\n", "/**\n * Hide it for documentation - but expose it because we will use this to render the list of wallets in docs website\n * Using dynamic import just to be extra safe and avoid any tree shaking issues\n * @internal\n */\nexport async function getAllWalletsList() {\n  return (await import(\"./__generated__/wallet-infos.js\")).default;\n}\n", "import type { Chain } from \"../chains/types.js\";\nimport { getCachedChainIfExists } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { Account, Wallet } from \"../wallets/interfaces/wallet.js\";\nimport { createWalletEmitter } from \"../wallets/wallet-emitter.js\";\n\nexport type AdapterWalletOptions = {\n  client: ThirdwebClient;\n  adaptedAccount: Account;\n  chain: Chain;\n  onDisconnect: () => Promise<void> | void;\n  switchChain: (chain: Chain) => Promise<void> | void;\n};\n\n/**\n * Creates a wallet from the given account.\n *\n * You can use this to:\n *\n * - convert a third party library wallet (wagmi, viem, ethers) into a thirdweb wallet.\n * - connect with a private key (for automated tests)\n *\n * Available wallet adatpers:\n * - [Viem](https://portal.thirdweb.com/references/typescript/v5/viemAdapter)\n * - [Ethers 6](https://portal.thirdweb.com/references/typescript/v5/ethers6Adapter)\n * - [Ethers 5](https://portal.thirdweb.com/references/typescript/v5/ethers5Adapter)\n *\n * @param options - The options for the adapter wallet.\n * @returns a wallet instance.\n *\n * @example\n * ```ts\n * import { createWalletAdapter } from \"thirdweb\";\n *\n * const wallet = createWalletAdapter({\n *  client,\n *  adaptedAccount,\n *  chain,\n *  onDisconnect: () => {\n *    // disconnect logic\n *  },\n *  switchChain: async (chain) => {\n *    // switch chain logic\n *  },\n * });\n * ```\n * @wallet\n */\nexport function createWalletAdapter(\n  options: AdapterWalletOptions,\n): Wallet<\"adapter\"> {\n  const emitter = createWalletEmitter<\"adapter\">();\n  let _chain = options.chain;\n  return {\n    id: \"adapter\",\n    subscribe: emitter.subscribe,\n    connect: async () => {\n      emitter.emit(\"onConnect\", options);\n      return options.adaptedAccount;\n    },\n    autoConnect: async () => {\n      emitter.emit(\"onConnect\", options);\n      return options.adaptedAccount;\n    },\n    disconnect: async () => {\n      await options.onDisconnect();\n      emitter.emit(\"disconnect\", undefined);\n    },\n    getAccount() {\n      return options.adaptedAccount;\n    },\n    getChain() {\n      const cachedChain = getCachedChainIfExists(_chain.id);\n      _chain = cachedChain || _chain;\n      return _chain;\n    },\n    getConfig() {\n      return options;\n    },\n    switchChain: async (chain) => {\n      await options.switchChain(chain);\n      _chain = chain;\n      emitter.emit(\"chainChanged\", chain);\n    },\n  };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgEM,SAAU,oBACd,SAAmC;AAEnC,QAAM,EAAE,OAAM,IAAK;AACnB,QAAM,aAAa,KAAK,QAAQ,WAAW,QAAQ,OAAO,EAAE,CAAC;AAE7D,QAAM,YAAY,MAAM,UAAU,aAAa,WAAW,MAAM,CAAC,GAAG,KAAK,CAAC;AAC1E,QAAM,UAAU,mBAAmB,SAAS;AAE5C,QAAM,UAAU;IACd;IACA,iBAAiB,OAGf,OACE;AACF,YAAM,aAAa,aAAa;QAC9B;QACA,OAAO,eAAe,GAAG,OAAO;OACjC;AACD,YAAM,WAAW,gBAAgB;QAC/B,aAAa;QACb;OACD;AACD,YAAM,kBAAkB,MAAM,uBAC5B,YACA,QAAQ;AAEV,aAAO;QACL;;IAEJ;IACA,aAAa,OAAO,EAAE,QAAO,MAAoC;AAC/D,aAAO,YAAY;QACjB;QACA;OACD;IACH;IACA,eAAe,OAIb,eACE;AACF,aAAO,cAAc;QACnB,GAAG;QACH;OACD;IACH;IACA,iBAAiB,OAAO,OAA+B;AACrD,aAAO,gBAAgB;QACrB,aAAa;QACb;OACD;IACH;;AAGF,SAAO;AACT;;;ACpGA,eAAsB,gBACpB,SAA+B;AAE/B,QAAM,aAAa,MAAM,UAAU,MAAM,iBAAgB,CAAE;AAC3D,SAAO,oBAAoB,EAAE,YAAY,QAAQ,QAAQ,OAAM,CAAE;AACnE;;;ACtBA,eAAsB,oBAAiB;AACrC,UAAQ,MAAM,OAAO,4BAAiC,GAAG;AAC3D;;;ACyCM,SAAU,oBACd,SAA6B;AAE7B,QAAM,UAAU,oBAAmB;AACnC,MAAI,SAAS,QAAQ;AACrB,SAAO;IACL,IAAI;IACJ,WAAW,QAAQ;IACnB,SAAS,YAAW;AAClB,cAAQ,KAAK,aAAa,OAAO;AACjC,aAAO,QAAQ;IACjB;IACA,aAAa,YAAW;AACtB,cAAQ,KAAK,aAAa,OAAO;AACjC,aAAO,QAAQ;IACjB;IACA,YAAY,YAAW;AACrB,YAAM,QAAQ,aAAY;AAC1B,cAAQ,KAAK,cAAc,MAAS;IACtC;IACA,aAAU;AACR,aAAO,QAAQ;IACjB;IACA,WAAQ;AACN,YAAM,cAAc,uBAAuB,OAAO,EAAE;AACpD,eAAS,eAAe;AACxB,aAAO;IACT;IACA,YAAS;AACP,aAAO;IACT;IACA,aAAa,OAAO,UAAS;AAC3B,YAAM,QAAQ,YAAY,KAAK;AAC/B,eAAS;AACT,cAAQ,KAAK,gBAAgB,KAAK;IACpC;;AAEJ;",
  "names": []
}
