import {
  hashMessage
} from "./chunk-NUMAW4ZH.js";
import {
  parseTypedData
} from "./chunk-QQQWUGLR.js";
import {
  sign
} from "./chunk-63PYJADF.js";
import {
  hashTypedData
} from "./chunk-VIJQ2DKR.js";
import {
  hexToBigInt
} from "./chunk-HBHEB2SD.js";
import {
  secp256k1
} from "./chunk-MCBKQZV4.js";

// node_modules/thirdweb/dist/esm/utils/signatures/signature-to-hex.js
function signatureToHex(signature) {
  const { r, s, v, yParity } = signature;
  const yParity_ = (() => {
    if (yParity === 0 || yParity === 1)
      return yParity;
    if (v && (v === 27n || v === 28n || v >= 35n))
      return v % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })();
  return `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? "1b" : "1c"}`;
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign-message.js
function signMessage(options) {
  if ("privateKey" in options) {
    const { message, privateKey } = options;
    const signature = sign({ hash: hashMessage(message), privateKey });
    return signatureToHex(signature);
  }
  if ("account" in options) {
    const { message, account } = options;
    return account.signMessage({ message });
  }
  throw new Error("Either privateKey or account is required");
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign-typed-data.js
function signTypedData(options) {
  const { privateKey, ...typedData } = options;
  const parsedTypeData = parseTypedData(typedData);
  const signature = sign({
    hash: hashTypedData(parsedTypeData),
    // TODO: Implement native hashTypedData
    privateKey
  });
  return signatureToHex(signature);
}

export {
  signatureToHex,
  signMessage,
  signTypedData
};
//# sourceMappingURL=chunk-M37VZ3HW.js.map
