import {
  download
} from "./chunk-6ZAO22CU.js";
import "./chunk-KLXH3ZM6.js";
import {
  MerkleTree,
  convertQuantity,
  hashEntry
} from "./chunk-67IDY2FH.js";
import "./chunk-FNFCYA7D.js";
import {
  ZERO_ADDRESS,
  isNativeTokenAddress
} from "./chunk-YCZ3YGMG.js";
import "./chunk-Q3JOSKWE.js";
import "./chunk-C4YSBPCB.js";
import "./chunk-PJWFC5K2.js";
import "./chunk-VIJQ2DKR.js";
import "./chunk-HBHEB2SD.js";
import "./chunk-GDDTQ4UI.js";
import "./chunk-HAADYJEF.js";
import "./chunk-MCBKQZV4.js";
import "./chunk-DZWKJ2HW.js";
import "./chunk-YMTKIPCL.js";
import "./chunk-KMJ22NCU.js";
import "./chunk-ODQ2TGHS.js";
import "./chunk-F7BKMWKP.js";
import "./chunk-3OXDSLPJ.js";
import "./chunk-PPP72TBL.js";
import "./chunk-MSFXBLHD.js";

// node_modules/thirdweb/dist/esm/utils/extensions/drops/fetch-proofs-for-claimers.js
async function fetchProofsForClaimer(options) {
  const { contract, merkleTreeUri, claimer } = options;
  const hashEntryFn = options.hashEntry || hashEntry;
  const response = await download({
    client: contract.client,
    uri: merkleTreeUri
  });
  const merkleInfo = await response.json();
  const shardId = claimer.slice(2, 2 + merkleInfo.shardNybbles).toLowerCase();
  const uri = merkleInfo.baseUri.endsWith("/") ? merkleInfo.baseUri : `${merkleInfo.baseUri}/`;
  let shardData;
  try {
    const constructedShardUri = `${uri}${shardId}.json`;
    const shard = await download({
      client: contract.client,
      uri: constructedShardUri
    });
    shardData = await shard.json();
  } catch {
    return null;
  }
  const hashedEntries = await Promise.all(shardData.entries.map(async (entry2) => {
    return hashEntryFn({
      entry: entry2,
      chain: contract.chain,
      client: contract.client,
      tokenDecimals: options.tokenDecimals
    });
  }));
  const tree = new MerkleTree(hashedEntries);
  const entry = shardData.entries.find((i) => i.address.toLowerCase() === claimer.toLowerCase());
  if (!entry) {
    return null;
  }
  const proof = tree.getHexProof(await hashEntryFn({
    entry,
    chain: contract.chain,
    client: contract.client,
    tokenDecimals: options.tokenDecimals
  })).concat(shardData.proofs);
  const currencyAddress = entry.currencyAddress || ZERO_ADDRESS;
  const currencyDecimals = await (async () => {
    if (isNativeTokenAddress(currencyAddress) || currencyAddress === ZERO_ADDRESS) {
      return 18;
    }
    const [{ getContract }, { decimals: getDecimals }] = await Promise.all([
      import("./contract-EIY2GISF.js"),
      import("./decimals-VRBK5JZJ.js")
    ]);
    const currencyContract = getContract({
      address: currencyAddress,
      chain: contract.chain,
      client: contract.client
    });
    return await getDecimals({ contract: currencyContract });
  })();
  return {
    proof,
    quantityLimitPerWallet: convertQuantity({
      quantity: entry.maxClaimable || "unlimited",
      tokenDecimals: options.tokenDecimals
    }),
    pricePerToken: convertQuantity({
      quantity: entry.price || "unlimited",
      tokenDecimals: currencyDecimals
    }),
    currency: currencyAddress
  };
}
export {
  fetchProofsForClaimer
};
//# sourceMappingURL=fetch-proofs-for-claimers-DSKQXUHM.js.map
