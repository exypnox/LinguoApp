{
  "version": 3,
  "sources": ["../../thirdweb/src/merkletree/MerkleTree.ts", "../../thirdweb/src/utils/extensions/drops/convert-quantity.ts", "../../thirdweb/src/utils/extensions/drops/hash-entry.ts"],
  "sourcesContent": ["// ADAPTED FROM https://github.com/merkletreejs/merkletreejs\nimport { type Hex, uint8ArrayToHex } from \"../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../utils/encoding/to-bytes.js\";\nimport { keccak256 } from \"../utils/hashing/keccak256.js\";\nimport {\n  areUint8ArraysEqual,\n  compareUint8Arrays,\n  concatUint8Arrays,\n} from \"../utils/uint8-array.js\";\n\n// TODO: clean this up more, there is probably something to be said to move this entirely out of a class\n\ntype TLeaf = Uint8Array;\ntype TLayer = Uint8Array[];\n\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nexport class MerkleTree {\n  private leaves: TLeaf[] = [];\n  private layers: TLayer[] = [];\n\n  constructor(leaves: (Uint8Array | Hex)[]) {\n    this.leaves = leaves.map((el) =>\n      el instanceof Uint8Array ? el : hexToBytes(el),\n    );\n\n    this.leaves = this.leaves.sort(compareUint8Arrays);\n\n    this.createHashes(this.leaves);\n  }\n\n  public getHexRoot(): `0x${string}` {\n    return uint8ArrayToHex(this.getRoot());\n  }\n\n  public getHexProof(leaf: Uint8Array | Hex, index?: number): `0x${string}`[] {\n    return this.getProof(leaf, index).map((item) => uint8ArrayToHex(item.data));\n  }\n\n  // private below\n\n  private createHashes(nodes: Uint8Array[]) {\n    this.layers = [nodes];\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n\n      this.layers.push([]);\n\n      const layerLimit = nodes.length;\n\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i >= layerLimit) {\n          // biome-ignore lint/style/noNonNullAssertion: in bounds\n          this.layers[layerIndex]!.push(...nodes.slice(layerLimit));\n          break;\n        }\n        if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            // push copy of hash and continue iteration\n            // biome-ignore lint/style/noNonNullAssertion: in bounds\n            this.layers[layerIndex]!.push(nodes[i]!);\n            continue;\n          }\n        }\n\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        const left = nodes[i]!;\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        const right = i + 1 === nodes.length ? left : nodes[i + 1]!;\n        const combined = [left, right];\n\n        combined.sort(compareUint8Arrays);\n\n        const hash = keccak256(concatUint8Arrays(combined), \"bytes\");\n\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        this.layers[layerIndex]!.push(hash);\n      }\n      // biome-ignore lint/style/noParameterAssign: part of the functionality\n      // biome-ignore lint/style/noNonNullAssertion: in bounds\n      nodes = this.layers[layerIndex]!;\n    }\n  }\n\n  private getRoot(): Uint8Array {\n    if (this.layers.length === 0) {\n      return new Uint8Array();\n    }\n\n    // biome-ignore lint/style/noNonNullAssertion: in bounds\n    return this.layers[this.layers.length - 1]![0] || new Uint8Array();\n  }\n\n  private getProof(\n    leaf: Uint8Array | Hex,\n    index?: number,\n  ): { position: \"left\" | \"right\"; data: Uint8Array }[] {\n    if (typeof leaf === \"undefined\") {\n      throw new Error(\"leaf is required\");\n    }\n    // biome-ignore lint/style/noParameterAssign: part of the functionality\n    leaf = leaf instanceof Uint8Array ? leaf : hexToBytes(leaf);\n    const proof = [];\n\n    if (!Number.isInteger(index)) {\n      // biome-ignore lint/style/noParameterAssign: part of the functionality\n      index = -1;\n\n      for (let i = 0; i < this.leaves.length; i++) {\n        // biome-ignore lint/style/noNonNullAssertion: within bounds\n        if (areUint8ArraysEqual(leaf, this.leaves[i]!)) {\n          // biome-ignore lint/style/noParameterAssign: part of the functionality\n          index = i;\n        }\n      }\n    }\n\n    // @ts-expect-error - issue from original code\n    if (index <= -1) {\n      return [];\n    }\n\n    for (let i = 0; i < this.layers.length; i++) {\n      // biome-ignore lint/style/noNonNullAssertion: in bounds\n      const layer = this.layers[i]!;\n      // @ts-expect-error - issue from original code\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode\n        ? // @ts-expect-error - issue from original code\n          index - 1\n        : // Proof Generation for Non-Bitcoin Trees\n          // @ts-expect-error - issue from original code\n          index + 1;\n\n      if (pairIndex < layer.length) {\n        proof.push({\n          position: isRightNode ? \"left\" : \"right\",\n          data: layer[pairIndex],\n        });\n      }\n\n      // set index to parent index\n      // @ts-expect-error - issue from original code\n      // biome-ignore lint/style/noParameterAssign: part of the functionality\n      index = (index / 2) | 0;\n    }\n\n    // @ts-expect-error - issue from original code\n    return proof;\n  }\n}\n", "import { maxUint256 } from \"viem\";\nimport { toUnits } from \"../../units.js\";\n\nexport function convertQuantity(options: {\n  quantity: string;\n  tokenDecimals: number;\n}) {\n  const { quantity, tokenDecimals } = options;\n  if (quantity === \"unlimited\") {\n    return maxUint256;\n  }\n  return toUnits(quantity, tokenDecimals);\n}\n", "import { encodePacked } from \"viem\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  ZERO_ADDRESS,\n  isNativeTokenAddress,\n} from \"../../../constants/addresses.js\";\nimport { keccak256 } from \"../../hashing/keccak256.js\";\nimport { convertQuantity } from \"./convert-quantity.js\";\nimport type { OverrideEntry } from \"./types.js\";\n\nexport async function hashEntry(options: {\n  entry: OverrideEntry;\n  chain: Chain;\n  client: ThirdwebClient;\n  tokenDecimals: number;\n}) {\n  const currencyAddress = options.entry.currencyAddress || ZERO_ADDRESS;\n  const currencyDecimals = await (async () => {\n    if (\n      isNativeTokenAddress(currencyAddress) ||\n      currencyAddress === ZERO_ADDRESS\n    ) {\n      return 18;\n    }\n    const [{ getContract }, { decimals: getDecimals }] = await Promise.all([\n      import(\"../../../contract/contract.js\"),\n      import(\"../../../extensions/erc20/read/decimals.js\"),\n    ]);\n    const currencyContract = getContract({\n      address: currencyAddress,\n      chain: options.chain,\n      client: options.client,\n    });\n    return await getDecimals({ contract: currencyContract });\n  })();\n\n  return keccak256(\n    encodePacked(\n      [\"address\", \"uint256\", \"uint256\", \"address\"],\n      [\n        options.entry.address,\n        convertQuantity({\n          quantity: options.entry.maxClaimable || \"unlimited\",\n          tokenDecimals: options.tokenDecimals,\n        }),\n        convertQuantity({\n          quantity: options.entry.price || \"unlimited\",\n          tokenDecimals: currencyDecimals,\n        }),\n        currencyAddress,\n      ],\n    ),\n  );\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBM,IAAO,aAAP,MAAiB;EAIrB,YAAY,QAA4B;AAHhC,WAAA,eAAA,MAAA,UAAA;;;;aAAkB,CAAA;;AAClB,WAAA,eAAA,MAAA,UAAA;;;;aAAmB,CAAA;;AAGzB,SAAK,SAAS,OAAO,IAAI,CAAC,OACxB,cAAc,aAAa,KAAK,WAAW,EAAE,CAAC;AAGhD,SAAK,SAAS,KAAK,OAAO,KAAK,kBAAkB;AAEjD,SAAK,aAAa,KAAK,MAAM;EAC/B;EAEO,aAAU;AACf,WAAO,gBAAgB,KAAK,QAAO,CAAE;EACvC;EAEO,YAAY,MAAwB,OAAc;AACvD,WAAO,KAAK,SAAS,MAAM,KAAK,EAAE,IAAI,CAAC,SAAS,gBAAgB,KAAK,IAAI,CAAC;EAC5E;;EAIQ,aAAa,OAAmB;AACtC,SAAK,SAAS,CAAC,KAAK;AACpB,WAAO,MAAM,SAAS,GAAG;AACvB,YAAM,aAAa,KAAK,OAAO;AAE/B,WAAK,OAAO,KAAK,CAAA,CAAE;AAEnB,YAAM,aAAa,MAAM;AAEzB,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,GAAG;AACxC,YAAI,KAAK,YAAY;AAEnB,eAAK,OAAO,UAAU,EAAG,KAAK,GAAG,MAAM,MAAM,UAAU,CAAC;AACxD;QACF;AACA,YAAI,IAAI,MAAM,MAAM,QAAQ;AAC1B,cAAI,MAAM,SAAS,MAAM,GAAG;AAG1B,iBAAK,OAAO,UAAU,EAAG,KAAK,MAAM,CAAC,CAAE;AACvC;UACF;QACF;AAGA,cAAM,OAAO,MAAM,CAAC;AAEpB,cAAM,QAAQ,IAAI,MAAM,MAAM,SAAS,OAAO,MAAM,IAAI,CAAC;AACzD,cAAM,WAAW,CAAC,MAAM,KAAK;AAE7B,iBAAS,KAAK,kBAAkB;AAEhC,cAAM,OAAO,UAAU,kBAAkB,QAAQ,GAAG,OAAO;AAG3D,aAAK,OAAO,UAAU,EAAG,KAAK,IAAI;MACpC;AAGA,cAAQ,KAAK,OAAO,UAAU;IAChC;EACF;EAEQ,UAAO;AACb,QAAI,KAAK,OAAO,WAAW,GAAG;AAC5B,aAAO,IAAI,WAAU;IACvB;AAGA,WAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC,EAAG,CAAC,KAAK,IAAI,WAAU;EAClE;EAEQ,SACN,MACA,OAAc;AAEd,QAAI,OAAO,SAAS,aAAa;AAC/B,YAAM,IAAI,MAAM,kBAAkB;IACpC;AAEA,WAAO,gBAAgB,aAAa,OAAO,WAAW,IAAI;AAC1D,UAAM,QAAQ,CAAA;AAEd,QAAI,CAAC,OAAO,UAAU,KAAK,GAAG;AAE5B,cAAQ;AAER,eAAS,IAAI,GAAG,IAAI,KAAK,OAAO,QAAQ,KAAK;AAE3C,YAAI,oBAAoB,MAAM,KAAK,OAAO,CAAC,CAAE,GAAG;AAE9C,kBAAQ;QACV;MACF;IACF;AAGA,QAAI,SAAS,IAAI;AACf,aAAO,CAAA;IACT;AAEA,aAAS,IAAI,GAAG,IAAI,KAAK,OAAO,QAAQ,KAAK;AAE3C,YAAM,QAAQ,KAAK,OAAO,CAAC;AAE3B,YAAM,cAAc,QAAQ;AAC5B,YAAM,YAAY;;QAEd,QAAQ;;;;QAGR,QAAQ;;AAEZ,UAAI,YAAY,MAAM,QAAQ;AAC5B,cAAM,KAAK;UACT,UAAU,cAAc,SAAS;UACjC,MAAM,MAAM,SAAS;SACtB;MACH;AAKA,cAAS,QAAQ,IAAK;IACxB;AAGA,WAAO;EACT;;;;ACpJI,SAAU,gBAAgB,SAG/B;AACC,QAAM,EAAE,UAAU,cAAa,IAAK;AACpC,MAAI,aAAa,aAAa;AAC5B,WAAO;EACT;AACA,SAAO,QAAQ,UAAU,aAAa;AACxC;;;ACDA,eAAsB,UAAU,SAK/B;AACC,QAAM,kBAAkB,QAAQ,MAAM,mBAAmB;AACzD,QAAM,mBAAmB,OAAO,YAAW;AACzC,QACE,qBAAqB,eAAe,KACpC,oBAAoB,cACpB;AACA,aAAO;IACT;AACA,UAAM,CAAC,EAAE,YAAW,GAAI,EAAE,UAAU,YAAW,CAAE,IAAI,MAAM,QAAQ,IAAI;MACrE,OAAO,wBAA+B;MACtC,OAAO,wBAA4C;KACpD;AACD,UAAM,mBAAmB,YAAY;MACnC,SAAS;MACT,OAAO,QAAQ;MACf,QAAQ,QAAQ;KACjB;AACD,WAAO,MAAM,YAAY,EAAE,UAAU,iBAAgB,CAAE;EACzD,GAAE;AAEF,SAAO,UACL,aACE,CAAC,WAAW,WAAW,WAAW,SAAS,GAC3C;IACE,QAAQ,MAAM;IACd,gBAAgB;MACd,UAAU,QAAQ,MAAM,gBAAgB;MACxC,eAAe,QAAQ;KACxB;IACD,gBAAgB;MACd,UAAU,QAAQ,MAAM,SAAS;MACjC,eAAe;KAChB;IACD;GACD,CACF;AAEL;",
  "names": []
}
