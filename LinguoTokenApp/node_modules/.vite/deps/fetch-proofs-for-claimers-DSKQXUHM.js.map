{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/extensions/drops/fetch-proofs-for-claimers.ts"],
  "sourcesContent": ["import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  ZERO_ADDRESS,\n  isNativeTokenAddress,\n} from \"../../../constants/addresses.js\";\nimport type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { MerkleTree } from \"../../../merkletree/MerkleTree.js\";\nimport { download } from \"../../../storage/download.js\";\nimport type { Address } from \"../../address.js\";\nimport type { Hex } from \"../../encoding/hex.js\";\nimport { convertQuantity } from \"./convert-quantity.js\";\nimport { hashEntry } from \"./hash-entry.js\";\nimport type {\n  OverrideEntry,\n  OverrideProof,\n  ShardData,\n  ShardedMerkleTreeInfo,\n} from \"./types.js\";\n\nexport async function fetchProofsForClaimer(options: {\n  contract: ThirdwebContract;\n  claimer: string;\n  merkleTreeUri: string;\n  tokenDecimals: number;\n  hashEntry?: (options: {\n    entry: OverrideEntry;\n    chain: Chain;\n    client: ThirdwebClient;\n    tokenDecimals: number;\n  }) => Promise<Hex>;\n}): Promise<OverrideProof | null> {\n  const { contract, merkleTreeUri, claimer } = options;\n  const hashEntryFn = options.hashEntry || hashEntry;\n\n  // 2. download snapshot data\n  const response = await download({\n    client: contract.client,\n    uri: merkleTreeUri,\n  });\n  const merkleInfo: ShardedMerkleTreeInfo = await response.json();\n\n  // 3. download shard data based off the user address\n  const shardId = claimer.slice(2, 2 + merkleInfo.shardNybbles).toLowerCase();\n  const uri = merkleInfo.baseUri.endsWith(\"/\")\n    ? merkleInfo.baseUri\n    : `${merkleInfo.baseUri}/`;\n  let shardData: ShardData;\n\n  try {\n    const constructedShardUri = `${uri}${shardId}.json`;\n    const shard = await download({\n      client: contract.client,\n      uri: constructedShardUri,\n    });\n    shardData = await shard.json();\n  } catch {\n    // if the file can't be fetched it means claimer not in merkle tree\n    return null;\n  }\n\n  // 4. hash all the entries in that shard and construct the sub merkle tree\n  const hashedEntries = await Promise.all(\n    shardData.entries.map(async (entry) => {\n      return hashEntryFn({\n        entry,\n        chain: contract.chain,\n        client: contract.client,\n        tokenDecimals: options.tokenDecimals,\n      });\n    }),\n  );\n  // 5. get the proof for the claimer + the sub merkle tree root\n  const tree = new MerkleTree(hashedEntries);\n  const entry = shardData.entries.find(\n    (i) => i.address.toLowerCase() === claimer.toLowerCase(),\n  );\n  if (!entry) {\n    return null;\n  }\n  const proof = tree\n    .getHexProof(\n      await hashEntryFn({\n        entry,\n        chain: contract.chain,\n        client: contract.client,\n        tokenDecimals: options.tokenDecimals,\n      }),\n    )\n    .concat(shardData.proofs);\n  // 6. return the proof and the entry data for the contract call\n  const currencyAddress = (entry.currencyAddress || ZERO_ADDRESS) as Address;\n  const currencyDecimals = await (async () => {\n    if (\n      isNativeTokenAddress(currencyAddress) ||\n      currencyAddress === ZERO_ADDRESS\n    ) {\n      return 18;\n    }\n    const [{ getContract }, { decimals: getDecimals }] = await Promise.all([\n      import(\"../../../contract/contract.js\"),\n      import(\"../../../extensions/erc20/read/decimals.js\"),\n    ]);\n    const currencyContract = getContract({\n      address: currencyAddress,\n      chain: contract.chain,\n      client: contract.client,\n    });\n    return await getDecimals({ contract: currencyContract });\n  })();\n\n  return {\n    proof,\n    quantityLimitPerWallet: convertQuantity({\n      quantity: entry.maxClaimable || \"unlimited\",\n      tokenDecimals: options.tokenDecimals,\n    }),\n    pricePerToken: convertQuantity({\n      quantity: entry.price || \"unlimited\",\n      tokenDecimals: currencyDecimals,\n    }),\n    currency: currencyAddress,\n  };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA,eAAsB,sBAAsB,SAW3C;AACC,QAAM,EAAE,UAAU,eAAe,QAAO,IAAK;AAC7C,QAAM,cAAc,QAAQ,aAAa;AAGzC,QAAM,WAAW,MAAM,SAAS;IAC9B,QAAQ,SAAS;IACjB,KAAK;GACN;AACD,QAAM,aAAoC,MAAM,SAAS,KAAI;AAG7D,QAAM,UAAU,QAAQ,MAAM,GAAG,IAAI,WAAW,YAAY,EAAE,YAAW;AACzE,QAAM,MAAM,WAAW,QAAQ,SAAS,GAAG,IACvC,WAAW,UACX,GAAG,WAAW,OAAO;AACzB,MAAI;AAEJ,MAAI;AACF,UAAM,sBAAsB,GAAG,GAAG,GAAG,OAAO;AAC5C,UAAM,QAAQ,MAAM,SAAS;MAC3B,QAAQ,SAAS;MACjB,KAAK;KACN;AACD,gBAAY,MAAM,MAAM,KAAI;EAC9B,QAAQ;AAEN,WAAO;EACT;AAGA,QAAM,gBAAgB,MAAM,QAAQ,IAClC,UAAU,QAAQ,IAAI,OAAOA,WAAS;AACpC,WAAO,YAAY;MACjB,OAAAA;MACA,OAAO,SAAS;MAChB,QAAQ,SAAS;MACjB,eAAe,QAAQ;KACxB;EACH,CAAC,CAAC;AAGJ,QAAM,OAAO,IAAI,WAAW,aAAa;AACzC,QAAM,QAAQ,UAAU,QAAQ,KAC9B,CAAC,MAAM,EAAE,QAAQ,YAAW,MAAO,QAAQ,YAAW,CAAE;AAE1D,MAAI,CAAC,OAAO;AACV,WAAO;EACT;AACA,QAAM,QAAQ,KACX,YACC,MAAM,YAAY;IAChB;IACA,OAAO,SAAS;IAChB,QAAQ,SAAS;IACjB,eAAe,QAAQ;GACxB,CAAC,EAEH,OAAO,UAAU,MAAM;AAE1B,QAAM,kBAAmB,MAAM,mBAAmB;AAClD,QAAM,mBAAmB,OAAO,YAAW;AACzC,QACE,qBAAqB,eAAe,KACpC,oBAAoB,cACpB;AACA,aAAO;IACT;AACA,UAAM,CAAC,EAAE,YAAW,GAAI,EAAE,UAAU,YAAW,CAAE,IAAI,MAAM,QAAQ,IAAI;MACrE,OAAO,wBAA+B;MACtC,OAAO,wBAA4C;KACpD;AACD,UAAM,mBAAmB,YAAY;MACnC,SAAS;MACT,OAAO,SAAS;MAChB,QAAQ,SAAS;KAClB;AACD,WAAO,MAAM,YAAY,EAAE,UAAU,iBAAgB,CAAE;EACzD,GAAE;AAEF,SAAO;IACL;IACA,wBAAwB,gBAAgB;MACtC,UAAU,MAAM,gBAAgB;MAChC,eAAe,QAAQ;KACxB;IACD,eAAe,gBAAgB;MAC7B,UAAU,MAAM,SAAS;MACzB,eAAe;KAChB;IACD,UAAU;;AAEd;",
  "names": ["entry"]
}
